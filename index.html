<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Priyome</title>

  <!-- chessboard.js (requires jQuery) -->
  <link rel="stylesheet"
        href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
        integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU"
        crossorigin="anonymous">
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"
          integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2"
          crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
          integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD"
          crossorigin="anonymous"></script>

  <!-- chess.js UMD (global Chess) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.11.0/chess.min.js"></script>

  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --text:#0f172a;
      --muted:#475569;
      --border:#dbe3f0;
      --accent:#2563eb;
      --green:#16a34a;
      --radius:14px;
      --shadow:0 10px 22px rgba(15,23,42,.08);
      --bad:#dc2626;
      --warn:#d97706;
    }
    *{box-sizing:border-box}
    html, body { height: 100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      overflow:auto;              /* CHANGED: allow page scroll to bottom */
      padding-bottom:5vh;         /* CHANGED: tiny ~5% bottom margin */
    }

    button{
      border:1px solid var(--border);
      background: #ffffff;
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
    }
    button:hover{filter:brightness(0.98)}
    button.on{
      border-color: rgba(22,163,74,.55);
      box-shadow:0 0 0 1px rgba(22,163,74,.20) inset;
    }

    /* --- Collapsible hamburger top bar --- */
    .topbarWrap{
      position:sticky; top:0; z-index:5;
      background: rgba(246,247,251,.92);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--border);
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      gap:10px;
    }
    .brand{
      display:flex; align-items:center; gap:10px; font-weight:900;
      min-width:0;
    }
    .hamburger{
      width:42px; height:42px;
      display:grid; place-items:center;
      font-size:18px;
      padding:0;
      flex:0 0 auto;
    }
    .brandTitle{font-size:16px; letter-spacing:.2px}
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--border);
      padding:3px 8px;
      border-radius:999px;
      background: rgba(37,99,235,.06);
      white-space:nowrap;
    }

    .menu{
      display:none;
      padding:10px 14px 14px;
      border-top:1px solid var(--border);
      background: rgba(255,255,255,.75);
    }
    .menu.open{display:block;}
    .actions{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    }

    /* --- Layout: board is upper half; panels lower half --- */
    .layout{
      max-width:1240px;
      margin:0 auto;
      padding:14px;
      min-height: calc(100vh - 60px); /* CHANGED: was fixed height; now page can extend */
      display:grid;
      grid-template-rows: 66vh 1fr;
      gap:14px;
      min-height:0;
    }
    @media (max-width:500px){
      .layout{ padding:10px; grid-template-rows: auto 1fr; }
    }

    .card{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      min-height:0;
    }
    .head{
      padding:10px 12px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border-bottom:1px solid var(--border);
      background: rgba(15,23,42,.02);
    }
    .status{font-size:12px; color:var(--muted)}

    .boardCard{ display:flex; flex-direction:column; min-height:0; }
    .boardArea{
      position:relative;
      padding:12px;
      flex:1;
      min-height:0;

      /* CHANGED: center the square board inside this area */
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* CHANGED: square board wrapper; JS sets px size so it always stays square and maximal */
    .boardWrap{
      position:relative;
      width:100%;
      height:100%;
      max-width:100%;
      max-height:100%;
    }
    #board{
      width:100%;
      height:100%;
    }

/* chessboard.js coordinate labels: smaller + corners (avoid overlapping pieces) */
#board .notation-322f9{
  font-size: 9px;
  line-height: 1;
  opacity: .70;
  pointer-events: none;
}

/* file letters: keep bottom-left */
#board .alpha-d2270{
  left: 2px !important;
  bottom: 2px !important;
}

/* rank numbers: keep top-right */
#board .numeric-fc462{
  right: 2px !important;
  top: 2px !important;
}
    #overlay{
      position:absolute;
      inset:0;
      pointer-events:none;
    }

    .below{
      padding:10px 12px 12px;
      border-top:1px solid var(--border);
      background: rgba(15,23,42,.02);
      display:grid; gap:8px;
    }
    .fenRow{display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:12px;}
    .fenLabel{color:var(--muted); font-weight:900; letter-spacing:.2px}
    .fenBox{
      flex:1; padding:8px 10px; border-radius:12px;
      border:1px solid var(--border);
      background: rgba(15,23,42,.03);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      overflow:auto; white-space:nowrap;
    }
    .hint{font-size:12px; color:var(--muted); line-height:1.35}

    .tabs{
      display:flex; gap:8px;
      padding:10px;
      border-bottom:1px solid var(--border);
      background: rgba(15,23,42,.02);
    }
    .tab{
      padding:8px 10px; border-radius:12px;
      border:1px solid var(--border);
      background: rgba(15,23,42,.02);
      color:var(--muted);
      font-weight:900; font-size:12px; cursor:pointer;
      user-select:none;
    }
    .tab.active{
      color:var(--text);
      border-color: rgba(37,99,235,.55);
      box-shadow:0 0 0 1px rgba(37,99,235,.15) inset;
      background: rgba(37,99,235,.06);
    }

    .rightCard{ min-height:0; display:flex; flex-direction:column; }

    /* NEW: make the lower-half content itself scrollable if needed */
    .pane{
      display:none;
      padding:12px;
      gap:10px;
      flex:1;
      min-height:0;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    .pane.active{display:flex; flex-direction:column;}

    /* Ensure the moves list is scrollable but doesn't hide the annotation box */
    .moves{overflow:auto; padding-right:4px; min-height:120px; flex:1;}

    /* CHANGED: improve move number column like lichess (gray paneled) */
    .moveRow{
      display:flex;
      gap:10px;
      padding:6px 6px;             /* slightly tighter -> more moves visible */
      border-radius:12px;
      align-items:flex-start;
    }
    .moveRow:hover{background:rgba(15,23,42,.03);}
    .mn{
      width:44px;                  /* a bit wider for larger move numbers */
      color:var(--muted);
      text-align:right;
      padding:6px 8px;
      border-radius:10px;
      background: rgba(15,23,42,.04);
      border:1px solid rgba(15,23,42,.06);
      flex:0 0 auto;
    }

    .ply{display:flex; gap:8px; flex-wrap:wrap; flex:1;}
    .ply button{
      padding:5px 8px;
      border-radius:12px;
      background:transparent;
      border:1px solid transparent;
      font-weight:700;
    }
    .ply button:hover{border-color:var(--border); background:rgba(15,23,42,.03);}
    .ply button.active{border-color:rgba(22,163,74,.55);}

    /* CHANGED: inline PGN comments like lichess */
    .cmt{
      display:inline-block;
      padding:2px 6px;
      border-radius:10px;
      border:1px solid rgba(15,23,42,.08);
      background: rgba(15,23,42,.03);
      color: rgba(15,23,42,.72);
      font-size:12px;
      line-height:1.25;
      max-width: 100%;
      white-space: normal;
    }

    textarea{
      width:100%;
      min-height:140px;
      resize:vertical;
      border-radius:12px; border:1px solid var(--border);
      background: rgba(15,23,42,.02);
      color:var(--text);
      padding:10px; outline:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    textarea:focus{border-color:rgba(37,99,235,.55); box-shadow:0 0 0 3px rgba(37,99,235,.10);}

    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .row label{min-width:120px; font-size:12px; color:var(--muted); font-weight:900}
    input[type="file"]{padding:6px}
    .smallBtn{padding:8px 10px; border-radius:10px; font-size:12px; font-weight:900;}

    .gameList{overflow:auto; display:flex; flex-direction:column; gap:10px; min-height:120px; flex:1;}
    .gameCard{
      border:1px solid var(--border);
      background: rgba(15,23,42,.02);
      border-radius:14px;
      padding:10px;
      cursor:pointer;
    }
    .gameCard:hover{filter:brightness(0.99)}
    .gameCard.active{border-color:rgba(37,99,235,.55); box-shadow:0 0 0 1px rgba(37,99,235,.12) inset;}
    .gameTitle{font-weight:900; font-size:13px; margin-bottom:4px;}
    .meta{font-size:12px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap;}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid var(--border);
      background: rgba(15,23,42,.02);
      color: rgba(15,23,42,.78);
    }

    /* Errors tab console */
    .errorTools{
      display:flex; gap:8px; align-items:center; justify-content:space-between;
      flex-wrap:wrap;
    }
    .errorBody{
      padding:10px 12px 12px;
      border:1px solid rgba(220,38,38,.25);
      background: rgba(220,38,38,.05);
      border-radius: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      white-space:pre-wrap;
      color:#7f1d1d;
      overflow:auto;
      min-height:160px;
      flex:1;
    }
    .okLine{color:#166534}
    .warnLine{color:#92400e}

    /* NEW: bottom card spacing/typography */
    .bottomWrap{
      max-width:1240px;
      margin:0 auto;
      padding:0 14px 0;
    }
    .bottomCard .head{border-bottom:1px solid var(--border);}
    .bottomGrid{
      padding:12px;
      display:grid;
      gap:10px;
    }
    .bottomGrid textarea{
      min-height: 180px;
    }
  </style>
</head>

<body>
  <div class="topbarWrap">
    <div class="topbar">
      <div class="brand">
        <button class="hamburger" id="btnHamburger" aria-label="Menu">☰</button>
        <span class="brandTitle">Priyome</span>
        <span class="pill" id="studyPill">Mock Study • 3 games</span>
        <span class="pill" id="gamePill">—</span>
      </div>
      <div class="pill" id="diagPill">diagnostics</div>
    </div>
    <div class="menu" id="menu">
      <div class="actions">
        <button id="btnPrev">◀︎</button>
        <button id="btnNext">▶︎</button>
        <button id="btnFlip">Flip</button>
        <button id="btnReset">Reset</button>

        <button id="btnSquares">Squares</button>
        <button id="btnArrows">Arrows</button>
        <button id="btnClear">Clear</button>

        <button id="btnExportGame">Export Game PGN</button>
        <button id="btnExportStudy">Export Study PGN</button>
      </div>
    </div>
  </div>

  <div class="layout">
    <!-- Top half: board -->
    <div class="card boardCard">
      <div class="head">
        <div class="status" id="status">—</div>
        <div class="status">Tool: <span id="toolStatus">none</span></div>
      </div>
      <div class="boardArea" id="boardArea" tabindex="0" aria-label="Chessboard area">
        <!-- CHANGED: wrap board+overlay so overlay matches the square board size -->
        <div class="boardWrap" id="boardWrap">
          <div id="board"></div>
          <svg id="overlay" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
        </div>
      </div>
      <div class="below">
        <div class="fenRow">
          <span class="fenLabel">FEN</span>
          <div class="fenBox" id="fenBox"></div>
        </div>
        <div class="hint" id="hint">
          <b>Squares:</b> tap a square to toggle highlight.<br/>
          <b>Arrows:</b> tap start square, then tap end square to toggle an arrow.<br/>
          (Turn tool off to move pieces normally.)
        </div>
      </div>
    </div>

    <!-- Lower half: tabs -->
    <div class="card rightCard">
      <div class="tabs">
        <div class="tab active" id="tabMoves">Moves</div>
        <div class="tab" id="tabGames">Games</div>
        <div class="tab" id="tabQuery">Query</div>
        <div class="tab" id="tabErrors">Errors</div>
      </div>

      <div class="pane active" id="paneMoves">
        <div class="hint">
          Click a move to jump. Annotation is saved per ply and exported as <span class="kbd">{ comment }</span>.
        </div>
        <div class="moves" id="moves"></div>
        <div>
          <div class="hint" id="annoTitle">Annotation</div>
          <textarea id="annoText" placeholder="Add a comment for this ply…"></textarea>
        </div>
      </div>

      <div class="pane" id="paneGames">
        <div class="hint">Games list. Click to load.</div>
        <div class="gameList" id="gameList"></div>
      </div>

      <!-- Query tab -->
      <div class="pane" id="paneQuery">
        <div class="hint">
          Load <span class="kbd">.cql</span> and <span class="kbd">.pgn</span>. CQL becomes editable. Run executes <span class="kbd">/wasm/cql_runner.js</span>.
          Discovered games from output are added to <b>Games</b>.
        </div>

        <div class="row">
          <label for="qCqlFile">CQL file</label>
          <input id="qCqlFile" type="file" accept=".cql"/>
          <span class="kbd" id="qCqlName">—</span>
        </div>

        <div class="row">
          <label for="qPgnFile">PGN file</label>
          <input id="qPgnFile" type="file" accept=".pgn"/>
          <span class="kbd" id="qPgnName">—</span>
        </div>

        <div class="row">
          <label for="qArgv">Argv</label>
          <input id="qArgv" type="text" value="-i /work/game.pgn /work/query.cql"
                 style="width:min(980px,100%); padding:8px 10px; border-radius:12px; border:1px solid var(--border); background:rgba(15,23,42,.02);"/>
        </div>

        <div class="row">
          <label>CQL (editable)</label>
          <span class="kbd">in-memory</span>
        </div>
        <textarea id="qCqlText" placeholder="CQL will load here; you can edit before running…"></textarea>

        <div class="row">
          <button class="smallBtn" id="qRun" disabled>Run Query</button>
          <span class="hint" id="qStatus">Choose files to enable.</span>
        </div>
      </div>

      <!-- Errors tab -->
      <div class="pane" id="paneErrors">
        <div class="errorTools">
          <div class="hint">All logs and errors show here.</div>
          <div class="row" style="margin-left:auto;">
            <span class="kbd">Lines</span>
            <span class="kbd" id="errCount">0</span>
            <button class="smallBtn" id="btnClearErrors" type="button">Clear</button>
          </div>
        </div>
        <div class="errorBody" id="errorLog"></div>
      </div>
    </div>
  </div>

  <!-- NEW: bottom card for position FEN + game PGN -->
  <div class="bottomWrap">
    <div class="card bottomCard">
      <div class="head">
        <div class="status">Position FEN & Game PGN</div>
        <div class="status" id="bottomMeta">—</div>
      </div>
      <div class="bottomGrid">
        <div class="fenRow">
          <span class="fenLabel">FEN</span>
          <div class="fenBox" id="fenBottom"></div>
        </div>
        <div class="hint">PGN shown includes inline <span class="kbd">{ comments }</span> (imported + your annotations).</div>
        <textarea id="pgnBottom" readonly></textarea>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- hamburger menu ----------
  const btnHamburger = document.getElementById('btnHamburger');
  const menu = document.getElementById('menu');
  btnHamburger.addEventListener('click', () => {
    menu.classList.toggle('open');
    // CHANGED: board gets re-maximized after layout changes
    sizeBoardSquare();
    if (board && typeof board.resize === 'function') board.resize();
    redrawDrawings();
  });

  // ---------- error logger ----------
  const errorLog = document.getElementById('errorLog');
  const errCount = document.getElementById('errCount');
  let errorLines = [];

  function logLine(kind, msg){
    const ts = new Date().toISOString().slice(11,19);
    const line = `[${ts}] ${kind}: ${msg}`;
    errorLines.push(line);
    errCount.textContent = String(errorLines.length);

    const el = document.createElement('div');
    el.textContent = line;
    if (kind === 'OK') el.className = 'okLine';
    if (kind === 'WARN') el.className = 'warnLine';
    errorLog.appendChild(el);
    errorLog.scrollTop = errorLog.scrollHeight;
  }

  window.addEventListener('error', (e) => {
    const where = e.filename ? ` @ ${e.filename}:${e.lineno}:${e.colno}` : '';
    logLine('ERR', `${e.message}${where}`);
  });

  window.addEventListener('unhandledrejection', (e) => {
    logLine('ERR', `Unhandled promise rejection: ${String(e.reason)}`);
  });

  document.getElementById('btnClearErrors').addEventListener('click', () => {
    errorLines = [];
    errCount.textContent = '0';
    errorLog.innerHTML = '';
    logLine('OK', 'Cleared error log.');
  });

  // ---------- dependency diagnostics ----------
  function diag(){
    logLine('OK', `User-Agent: ${navigator.userAgent}`);
    const haveJQ = (typeof window.jQuery !== 'undefined');
    logLine(haveJQ ? 'OK' : 'ERR', `jQuery loaded: ${haveJQ}`);

    const haveChessboard = (typeof window.Chessboard !== 'undefined');
    logLine(haveChessboard ? 'OK' : 'ERR', `Chessboard loaded: ${haveChessboard}`);

    const haveChess = (typeof window.Chess !== 'undefined');
    logLine(haveChess ? 'OK' : 'ERR', `Chess (chess.js) loaded: ${haveChess}`);

    const testImg = new Image();
    testImg.onload = () => logLine('OK', 'Piece sprite reachable (wikipedia set).');
    testImg.onerror = () => logLine('ERR', 'Piece sprite failed to load (CDN blocked?).');
    testImg.src = 'https://koblenski.github.io/javascript/chessboardjs-0.3.0/img/chesspieces/wikipedia/Wp.png';
  }

  // ---------- mock games ----------
  let GAMES = [
    {
      id:"mock1", title:"Mock Game 1", opening:"English (mock)", result:"1-0",
      pgn:`[Event "Mock Study"]
[Site "Local"]
[Date "2026.01.01"]
[Round "1"]
[White "lexspec"]
[Black "mockbot"]
[Result "1-0"]

1. c4 e5 2. g3 Nf6 3. Bg2 Bc5 4. d3 O-O 5. Nc3 Re8 6. Nf3 c6 7. O-O d5 8. cxd5 cxd5 9. Bg5 Be6 10. Nxe5 1-0`
    },
    {
      id:"mock2", title:"Mock Game 2", opening:"Caro-Kann (mock)", result:"0-1",
      pgn:`[Event "Mock Study"]
[Site "Local"]
[Date "2026.01.01"]
[Round "2"]
[White "mockbot"]
[Black "lexspec"]
[Result "0-1"]

1. e4 c6 2. d4 d5 3. Nc3 dxe4 4. Nxe4 Nd7 5. Ng5 Ngf6 6. Bd3 e6 7. N1f3 h6 8. Nxf7 Kxf7 9. O-O Bd6 0-1`
    },
    {
      id:"mock3", title:"Mock Game 3", opening:"Ruy Lopez (mock)", result:"1/2-1/2",
      pgn:`[Event "Mock Study"]
[Site "Local"]
[Date "2026.01.01"]
[Round "3"]
[White "lexspec"]
[Black "mockbot"]
[Result "1/2-1/2"]

1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8 1/2-1/2`
    },
  ];
  const discoveredIds = new Set();

  // ---------- DOM ----------
  const statusEl = document.getElementById('status');
  const fenBox = document.getElementById('fenBox');
  const movesEl = document.getElementById('moves');
  const gameListEl = document.getElementById('gameList');
  const gamePill = document.getElementById('gamePill');
  const toolStatusEl = document.getElementById('toolStatus');
  const annoTitleEl = document.getElementById('annoTitle');
  const annoTextEl = document.getElementById('annoText');
  const overlay = document.getElementById('overlay');

  // NEW bottom card DOM
  const fenBottom = document.getElementById('fenBottom');
  const pgnBottom = document.getElementById('pgnBottom');
  const bottomMeta = document.getElementById('bottomMeta');

  // Query tab DOM
  const qCqlFile = document.getElementById('qCqlFile');
  const qPgnFile = document.getElementById('qPgnFile');
  const qCqlName = document.getElementById('qCqlName');
  const qPgnName = document.getElementById('qPgnName');
  const qCqlText = document.getElementById('qCqlText');
  const qArgv = document.getElementById('qArgv');
  const qRun = document.getElementById('qRun');
  const qStatus = document.getElementById('qStatus');

  // ---------- state ----------
  let board = null;
  let orientation = 'white';
  let currentGame = null;

  let game = null;
  let verboseHistory = [];
  let activePly = 0;

  const annotations = Object.create(null);
  const drawings = Object.create(null);

  // CHANGED: imported comments (from PGN) live here per game, but we merge them into annotations on load
  const imported = Object.create(null); // imported[gameId] = {ply: comment}

  function ensureStores(gameId){
    if (!annotations[gameId]) annotations[gameId] = Object.create(null);
    if (!drawings[gameId]) drawings[gameId] = { squares:Object.create(null), arrows:[] };
    if (!imported[gameId]) imported[gameId] = Object.create(null);
  }

  const Tool = { NONE:'none', SQUARES:'squares', ARROWS:'arrows' };
  let tool = Tool.NONE;
  let tapFrom = null;

  // Only suppress navigation gestures while a piece is actively being dragged
  let isDraggingPiece = false;

  function setTool(t){
    tool = t;
    tapFrom = null;
    toolStatusEl.textContent = t;
    document.getElementById('btnSquares').classList.toggle('on', t === Tool.SQUARES);
    document.getElementById('btnArrows').classList.toggle('on', t === Tool.ARROWS);
    logLine('OK', `Tool set to: ${t}`);
  }

  // ---------- board sizing (square, maximal) ----------
  const boardArea = document.getElementById('boardArea');
  const boardWrap = document.getElementById('boardWrap');

function sizeBoardSquare(){
  const cs = getComputedStyle(boardArea);
  const padX = (parseFloat(cs.paddingLeft)||0) + (parseFloat(cs.paddingRight)||0);
  const padY = (parseFloat(cs.paddingTop)||0) + (parseFloat(cs.paddingBottom)||0);

  const w = Math.max(0, boardArea.clientWidth - padX);
  const h = Math.max(0, boardArea.clientHeight - padY);

  const isMobile = window.matchMedia('(max-width: 980px)').matches;

  let s;
  if (isMobile){
    // mobile: board should be full card width; height grows to match
    s = Math.floor(w);
    // ensure the area can actually fit the square (page can scroll)
    boardArea.style.minHeight = (s + padY) + 'px';
  } else {
    // desktop: target ~2/3 viewport width, but don't exceed available width/height
    const target = Math.floor(window.innerWidth * (2/3));
    s = Math.floor(Math.min(w, h, target));
    boardArea.style.minHeight = ''; // reset any mobile override
  }

  boardWrap.style.width = s + 'px';
  boardWrap.style.height = s + 'px';
}

  // ---------- overlay ----------
  function clearOverlay(){ while(overlay.firstChild) overlay.removeChild(overlay.firstChild); }

  function ensureDefs(){
    let defs = overlay.querySelector('defs');
    if (!defs){
      defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      overlay.appendChild(defs);
    }
    if (!overlay.querySelector('#arrowHead')){
      const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
      marker.setAttribute('id','arrowHead');
      marker.setAttribute('markerWidth','6');
      marker.setAttribute('markerHeight','6');
      marker.setAttribute('refX','5.2');
      marker.setAttribute('refY','3');
      marker.setAttribute('orient','auto');
      marker.setAttribute('markerUnits','strokeWidth');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d','M0,0 L6,3 L0,6 Z');
      path.setAttribute('fill', '#16a34a');
      marker.appendChild(path);
      defs.appendChild(marker);
    }
  }

  function squareToXY(sq){
    const f = sq.charCodeAt(0)-97;
    const r = parseInt(sq[1],10)-1;
    if (orientation === 'white'){
      return { x:(f+0.5)*12.5, y:(7-r+0.5)*12.5 };
    } else {
      return { x:(7-f+0.5)*12.5, y:(r+0.5)*12.5 };
    }
  }

  function drawSquare(sq){
    const {x,y} = squareToXY(sq);
    const size = 12.5;
    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', x - size/2);
    rect.setAttribute('y', y - size/2);
    rect.setAttribute('width', size);
    rect.setAttribute('height', size);
    rect.setAttribute('fill', '#16a34a');
    rect.setAttribute('opacity', '0.16');
    overlay.appendChild(rect);
  }

  function drawArrow(from,to){
    const a = squareToXY(from), b = squareToXY(to);
    const dx=b.x-a.x, dy=b.y-a.y;
    const len=Math.hypot(dx,dy)||1;
    const shrink=4;
    const ux=dx/len, uy=dy/len;

    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', a.x);
    line.setAttribute('y1', a.y);
    line.setAttribute('x2', b.x - ux*shrink);
    line.setAttribute('y2', b.y - uy*shrink);
    line.setAttribute('stroke', '#16a34a');
    line.setAttribute('stroke-width', '1.7');
    line.setAttribute('opacity', '0.92');
    line.setAttribute('marker-end', 'url(#arrowHead)');
    overlay.appendChild(line);
  }

  function redrawDrawings(){
    clearOverlay();
    ensureDefs();
    if (!currentGame) return;
    const d = drawings[currentGame.id];
    if (!d) return;
    for (const sq of Object.keys(d.squares)){ if (d.squares[sq]) drawSquare(sq); }
    for (const ar of d.arrows){ drawArrow(ar.from, ar.to); }
  }

  function toggleSquare(gameId,sq){
    ensureStores(gameId);
    drawings[gameId].squares[sq] = !drawings[gameId].squares[sq];
    logLine('OK', `Square ${sq} => ${drawings[gameId].squares[sq] ? 'ON' : 'OFF'}`);
  }

  function toggleArrow(gameId,from,to){
    if (from===to) return;
  ensureStores(gameId);

  // undirected key for dedupe, but KEEP the original direction for drawing
  const key = (from < to) ? `${from}-${to}` : `${to}-${from}`;
  const arr = drawings[gameId].arrows;

  const idx = arr.findIndex(x => {
    const k = (x.from < x.to) ? `${x.from}-${x.to}` : `${x.to}-${x.from}`;
    return k === key;
  });

    if (idx >= 0){
    arr.splice(idx, 1);
    logLine('OK', `Arrow ${key} removed`);
    } else {
    arr.push({from, to}); // keep the direction the user tapped
    logLine('OK', `Arrow ${from}->${to} added`);
    }
  }

  function clearAll(gameId){
    ensureStores(gameId);
    drawings[gameId].squares = Object.create(null);
    drawings[gameId].arrows = [];
    logLine('OK', 'Cleared drawings.');
  }

  // ---------- tabs ----------
  function setTab(which){
    const map = {
      moves: ['tabMoves','paneMoves'],
      games: ['tabGames','paneGames'],
      query: ['tabQuery','paneQuery'],
      errors:['tabErrors','paneErrors'],
    };

    for (const k of Object.keys(map)){
      const [t,p] = map[k];
      document.getElementById(t).classList.toggle('active', k===which);
      document.getElementById(p).classList.toggle('active', k===which);
    }
    logLine('OK', `Tab: ${which}`);
  }

  document.getElementById('tabMoves').addEventListener('click', () => setTab('moves'));
  document.getElementById('tabGames').addEventListener('click', () => setTab('games'));
  document.getElementById('tabQuery').addEventListener('click', () => setTab('query'));
  document.getElementById('tabErrors').addEventListener('click', () => setTab('errors'));

  // ---------- move list / nav ----------
  function rebuildToPly(ply){
    game.reset();
    for (let i=0;i<ply;i++){
      const mv = verboseHistory[i];
      if (!mv) break;
      game.move({from:mv.from,to:mv.to,promotion:mv.promotion||'q'});
    }
  }

  function setStatus(){
    let s = `${game.turn()==='w'?'White':'Black'} to move.`;
    if (game.in_check()) s += ' (Check)';
    if (game.game_over()){
      if (game.in_checkmate()) s = `Checkmate. ${game.turn()==='w'?'Black':'White'} wins.`;
      else if (game.in_draw()) s = 'Draw.';
      else s = 'Game over.';
    }
    statusEl.textContent = s;
  }

  function setFen(){
    const f = game.fen();
    fenBox.textContent = f;
    fenBottom.textContent = f;
  }

  // CHANGED: parse PGN comments { ... } and map them to ply index (1-based)
  function parsePgnCommentsByPly(pgn){
    const map = Object.create(null);
    const body = String(pgn || "").replace(/\r/g,'').replace(/^\s*\[[^\]]+\]\s*$/gm,'').trim();
    if (!body) return map;

    let ply = 0;
    // Tokenize: we only care about move numbers, comments, and SAN-ish tokens.
    const re = /\{[^}]*\}|\d+\.(?:\.\.)?|1-0|0-1|1\/2-1\/2|\*|\S+/g;
    let m;
    while ((m = re.exec(body)) !== null){
      const tok = m[0];

      if (tok.startsWith('{')){
        const c = tok.slice(1,-1).trim();
        if (c && ply > 0){
          map[ply] = (map[ply] ? (map[ply] + ' ' + c) : c);
        }
        continue;
      }
      if (/^\d+\.(?:\.\.)?$/.test(tok)) continue;
      if (/^(1-0|0-1|1\/2-1\/2|\*)$/.test(tok)) break;

      // likely a SAN token
      ply++;
    }
    return map;
  }

  function mergedComment(gameId, ply){
    ensureStores(gameId);
    const a = (annotations[gameId] && annotations[gameId][ply]) ? String(annotations[gameId][ply]).trim() : "";
    return a;
  }

  function renderMoves(){
    movesEl.innerHTML = '';
    const total = verboseHistory.length;
    const rows = Math.ceil(total/2);

    for (let m=0;m<rows;m++){
      const row = document.createElement('div');
      row.className = 'moveRow';

      const mn = document.createElement('div');
      mn.className='mn';
      mn.textContent = `${m+1}.`;
      row.appendChild(mn);

      const ply = document.createElement('div');
      ply.className='ply';

      const wi = m*2;
      const bi = m*2+1;

      const wBtn = document.createElement('button');
      wBtn.textContent = verboseHistory[wi]?.san || '';
      wBtn.disabled = !verboseHistory[wi];
      if (activePly === wi+1) wBtn.classList.add('active');
      wBtn.onclick = () => jumpTo(wi+1);
      ply.appendChild(wBtn);

      // CHANGED: inline comment after white move
      const wc = mergedComment(currentGame.id, wi+1);
      if (wc){
        const s = document.createElement('span');
        s.className = 'cmt';
        s.textContent = `{ ${wc} }`;
        ply.appendChild(s);
      }

      const bBtn = document.createElement('button');
      bBtn.textContent = verboseHistory[bi]?.san || '';
      bBtn.disabled = !verboseHistory[bi];
      if (activePly === bi+1) bBtn.classList.add('active');
      bBtn.onclick = () => jumpTo(bi+1);
      ply.appendChild(bBtn);

      // CHANGED: inline comment after black move
      const bc = mergedComment(currentGame.id, bi+1);
      if (bc){
        const s = document.createElement('span');
        s.className = 'cmt';
        s.textContent = `{ ${bc} }`;
        ply.appendChild(s);
      }

      row.appendChild(ply);
      movesEl.appendChild(row);
    }
  }

  function updateAnnoUI(){
    ensureStores(currentGame.id);
    annoTitleEl.textContent = `Annotation (ply ${activePly}${activePly===0?' / start':''})`;
    annoTextEl.value = annotations[currentGame.id][activePly] || '';
  }

  function updateBottomCard(){
    if (!currentGame){
      bottomMeta.textContent = '—';
      pgnBottom.value = '';
      return;
    }
    bottomMeta.textContent = currentGame.title;
    pgnBottom.value = pgnWithComments(currentGame.id, currentGame.pgn) + '\n';
  }

  function jumpTo(ply){
    activePly = Math.max(0, Math.min(ply, verboseHistory.length));
    rebuildToPly(activePly);
    board.position(game.fen(), false);
    setStatus(); setFen(); renderMoves(); updateAnnoUI(); redrawDrawings();
    updateBottomCard();
    logLine('OK', `Jump to ply ${activePly}`);
  }

  // ---------- board callbacks ----------
  function onDragStart(source, piece){
    if (tool !== Tool.NONE) return false;
    if (game.game_over()) return false;
    if (activePly !== verboseHistory.length) return false;
    if (game.turn()==='w' && piece.startsWith('b')) return false;
    if (game.turn()==='b' && piece.startsWith('w')) return false;

    isDraggingPiece = true;
    return true;
  }

  function onDrop(source,target){
    const mv = game.move({from:source,to:target,promotion:'q'});
    isDraggingPiece = false;
    if (!mv) return 'snapback';
    verboseHistory = game.history({verbose:true});
    activePly = verboseHistory.length;
    setStatus(); setFen(); renderMoves(); updateAnnoUI();
    updateBottomCard();
    logLine('OK', `Move: ${mv.san}`);
  }

  function onSnapEnd(){
    isDraggingPiece = false;
    board.position(game.fen(), false);
  }

  document.addEventListener('touchmove', (e) => {
    if (isDraggingPiece) e.preventDefault();
  }, { passive:false });

  window.addEventListener('mouseup', () => { isDraggingPiece = false; });

  // ---------- square detection ----------

function squareFromTarget(t){
  const el = t.closest?.('div.square-55d63');
  if (!el) return null;

  const sqClass = Array.from(el.classList).find(c => /^square-[a-h][1-8]$/.test(c));
  return sqClass ? sqClass.slice('square-'.length) : null;
}

  document.getElementById('boardArea').addEventListener('click', (e) => {
    if (!currentGame) return;
    if (tool === Tool.NONE) return;

    const sq = squareFromTarget(e.target);
    if (!sq) return;

    if (tool === Tool.SQUARES){
      toggleSquare(currentGame.id, sq);
      redrawDrawings();
      return;
    }

    if (tool === Tool.ARROWS){
      if (!tapFrom){
        tapFrom = sq;
        logLine('OK', `Arrow start = ${sq} (tap destination)`);
      } else {
        toggleArrow(currentGame.id, tapFrom, sq);
        tapFrom = null;
        redrawDrawings();
      }
    }
  });

  // ---------- games list ----------
  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  function renderGameList(){
    gameListEl.innerHTML = '';
    for (const g of GAMES){
      const card = document.createElement('div');
      card.className = 'gameCard' + (currentGame?.id === g.id ? ' active' : '');
      card.innerHTML = `
        <div class="gameTitle">${escapeHtml(g.title)}</div>
        <div class="meta"><span class="kbd">${escapeHtml(g.result || '*')}</span><span>${escapeHtml(g.opening || '')}</span></div>
      `;
      card.onclick = () => loadGame(g.id);
      gameListEl.appendChild(card);
    }
  }

  function loadGame(gameId){
    const g = GAMES.find(x => x.id===gameId);
    if (!g) return;

    currentGame = g;
    ensureStores(g.id);
    gamePill.textContent = g.title;

    // CHANGED: import existing PGN comments and preserve them by merging into annotations
    const importedMap = parsePgnCommentsByPly(g.pgn);
    imported[g.id] = importedMap;

    // Merge imported comments into annotations (but do not overwrite user edits)
    for (const k of Object.keys(importedMap)){
      const ply = parseInt(k,10);
      if (!annotations[g.id][ply] || !String(annotations[g.id][ply]).trim()){
        annotations[g.id][ply] = importedMap[ply];
      }
    }

    game.reset();
    const ok = game.load_pgn(g.pgn, {sloppy:true});
    logLine(ok ? 'OK' : 'ERR', `load_pgn(${g.title}) => ${ok}`);

    verboseHistory = game.history({verbose:true});
    activePly = verboseHistory.length;

    // CHANGED: size the square before init/resize so chessboard renders correctly
    sizeBoardSquare();

    if (!board){
      logLine('OK', 'Initializing Chessboard...');
      board = Chessboard('board', {
        draggable:true,
        position: game.fen(),
        pieceTheme: 'https://koblenski.github.io/javascript/chessboardjs-0.3.0/img/chesspieces/wikipedia/{piece}.png',
        onDragStart, onDrop, onSnapEnd
      });
      sizeBoardSquare();
      if (typeof board.resize === 'function') board.resize();
      logLine('OK', 'Chessboard initialized.');
    } else {
      board.position(game.fen(), false);
      if (typeof board.resize === 'function') board.resize();
      logLine('OK', `Chessboard position updated.`);
    }

    setStatus(); setFen(); renderMoves(); updateAnnoUI(); redrawDrawings();
    updateBottomCard();
    renderGameList();
  }

  // ---------- export ----------
  function downloadText(filename, text){
    const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },0);
    logLine('OK', `Downloaded: ${filename}`);
  }

  function pgnWithComments(gameId, basePgn){
    ensureStores(gameId);
    const tmp = new Chess();
    tmp.load_pgn(basePgn, {sloppy:true});
    const headers = tmp.header();
    const hist = tmp.history({verbose:true});
    const ann = annotations[gameId] || {};

    const headerLines = Object.keys(headers).map(k => `[${k} "${String(headers[k]).replaceAll('"','\\"')}"]`);
    if (!headers.Result) headerLines.push(`[Result "*"]`);

    const parts = [];
    for (let i=0;i<hist.length;i++){
      const ply = i+1;
      const moveNo = Math.floor(i/2)+1;
      const san = hist[i].san;
      if (i%2===0) parts.push(`${moveNo}. ${san}`);
      else parts.push(`${san}`);
      const c = (ann[ply]||'').trim();
      if (c) parts.push(`{ ${c.replace(/\s+/g,' ').trim()} }`);
    }

    const result = headers.Result || '*';
    return `${headerLines.join('\n')}\n\n${parts.join(' ')} ${result}`.trim();
  }

  document.getElementById('btnExportGame').onclick = () => {
    if (!currentGame) return;
    downloadText(`${currentGame.title.replace(/\s+/g,'_')}.pgn`, pgnWithComments(currentGame.id, currentGame.pgn) + '\n');
  };
  document.getElementById('btnExportStudy').onclick = () => {
    const blocks = GAMES.map(g => pgnWithComments(g.id, g.pgn));
    downloadText(`Study.pgn`, blocks.join('\n\n\n') + '\n');
  };

  // ---------- buttons ----------
  document.getElementById('btnPrev').onclick = () => { if (game) jumpTo(activePly - 1); };
  document.getElementById('btnNext').onclick = () => { if (game) jumpTo(activePly + 1); };

  document.getElementById('btnFlip').onclick = () => {
    if (!board) return;
    board.flip();
    orientation = (orientation==='white') ? 'black' : 'white';
    redrawDrawings();
    logLine('OK', `Flip => ${orientation}`);
  };

  document.getElementById('btnReset').onclick = () => {
    if (!board || !game) return;
    game.reset();
    verboseHistory = [];
    activePly = 0;
    board.start(false);
    sizeBoardSquare();
    if (typeof board.resize === 'function') board.resize();
    setStatus(); setFen(); renderMoves(); updateAnnoUI(); redrawDrawings();
    updateBottomCard();
    logLine('OK', 'Reset line to start position.');
  };

  document.getElementById('btnSquares').onclick = () => setTool(tool===Tool.SQUARES ? Tool.NONE : Tool.SQUARES);
  document.getElementById('btnArrows').onclick = () => setTool(tool===Tool.ARROWS ? Tool.NONE : Tool.ARROWS);
  document.getElementById('btnClear').onclick = () => { if(currentGame){ clearAll(currentGame.id); redrawDrawings(); } };

  annoTextEl.addEventListener('input', () => {
    if (!currentGame) return;
    ensureStores(currentGame.id);
    annotations[currentGame.id][activePly] = annoTextEl.value;
    updateBottomCard();
    logLine('OK', `Annotation saved for ply ${activePly} (${annoTextEl.value.length} chars)`);
  });

  window.addEventListener('resize', () => {
    sizeBoardSquare();
    redrawDrawings();
    if (board && typeof board.resize === 'function') board.resize();
  });

  // ---------- Query tab: lazy-load runner from /wasm/cql_runner.js ----------
  function updateQueryUi(){
    const haveCql = !!qCqlText.value.trim();
    const havePgn = !!qPgnFile.files?.[0];
    qRun.disabled = !(haveCql && havePgn);
    qStatus.textContent = qRun.disabled ? "Choose PGN and provide CQL (file or edit box) to enable." : "Ready.";
  }

  qCqlFile.addEventListener('change', async () => {
    const f = qCqlFile.files?.[0];
    qCqlName.textContent = f ? f.name : "—";
    if (!f) { updateQueryUi(); return; }
    try{
      const txt = await f.text();
      qCqlText.value = txt;
      logLine('OK', `Loaded CQL file (${txt.length} chars): ${f.name}`);
    }catch(e){
      logLine('ERR', `Failed reading CQL: ${String(e)}`);
    }finally{
      updateQueryUi();
    }
  });

  qPgnFile.addEventListener('change', () => {
    const f = qPgnFile.files?.[0];
    qPgnName.textContent = f ? f.name : "—";
    if (f) logLine('OK', `Selected PGN file: ${f.name}`);
    updateQueryUi();
  });

  qCqlText.addEventListener('input', updateQueryUi);

  async function fileToUint8(file) {
    const ab = await file.arrayBuffer();
    return new Uint8Array(ab);
  }
  function textToUtf8Bytes(text){
    return new TextEncoder().encode(text ?? "");
  }

  function parseHeaders(pgn){
    const headers = {};
    const headerRe = /^\[([A-Za-z0-9_]+)\s+"([^"]*)"\]\s*$/gm;
    let m;
    while ((m = headerRe.exec(pgn)) !== null){
      headers[m[1]] = m[2];
    }
    return headers;
  }
  function splitMultiPgn(text){
    const t = (text || "").trim();
    if (!t) return [];
    return t.split(/\n\s*\n(?=\[Event\s+)/g).map(s => s.trim()).filter(Boolean);
  }

  function addDiscoveredGamesFromPgn(multiPgnText){
    const games = splitMultiPgn(multiPgnText);
    if (!games.length){
      logLine('WARN', 'No games found in output PGN.');
      return 0;
    }
    let added = 0;
    for (let i=0;i<games.length;i++){
      const pgn = games[i];
      const h = parseHeaders(pgn);
      const title = h.Event ? h.Event : `Discovered Game ${i+1}`;
      const white = h.White || "?";
      const black = h.Black || "?";
      const date  = h.Date || "";
      const res   = h.Result || "*";

      const id = `disc:${(title+"|"+white+"|"+black+"|"+date).replace(/\s+/g,'_').slice(0,160)}`;
      if (discoveredIds.has(id)) continue;
      discoveredIds.add(id);

      GAMES.unshift({
        id,
        title: `${title} — ${white} vs ${black}`,
        opening: (h.Opening || "Discovered"),
        result: res,
        pgn
      });
      added++;
    }
    if (added){
      logLine('OK', `Added ${added} discovered game(s) to Games tab.`);
      renderGameList();
    }
    return added;
  }

  qRun.addEventListener('click', async () => {
    try{
      const pgnFile = qPgnFile.files?.[0];
      if (!pgnFile) throw new Error("Pick a PGN file.");
      const cqlText = qCqlText.value || "";
      if (!cqlText.trim()) throw new Error("CQL is empty.");

      qRun.disabled = true;
      qStatus.textContent = "Running…";
      logLine('OK', `Running query with argv: ${qArgv.value}`);

      let runCqlWasm;
      try{
        const mod = await import('/wasm/cql_runner.js');
        runCqlWasm = mod.runCqlWasm;
        if (typeof runCqlWasm !== 'function') throw new Error("runCqlWasm export not found");
      }catch(e){
        throw new Error("Failed to load /wasm/cql_runner.js. " + String(e));
      }

      const cqlBytes = textToUtf8Bytes(cqlText);
      const pgnBytes = await fileToUint8(pgnFile);

      const job = runCqlWasm(cqlBytes, pgnBytes, qArgv.value, {
        onLog: (line) => {
          const s = String(line);
          if (s.startsWith("[stderr]")) logLine('WARN', s);
          else logLine('OK', s);
        }
      });

      const unsub = job.subscribe((j) => {
        const st = j.status ? j.status() : {busy:0,total:1};
        qStatus.textContent = `${j.state} — workers ${st.busy}/${st.total}` + (j.error ? ` — ${j.error}` : "");
        if (j.state === "done" || j.state === "error"){
          unsub();
          if (j.state === "error"){
            logLine('ERR', `Query failed: ${j.error || "unknown error"}`);
            setTab('errors');
          } else {
            logLine('OK', `Query done (rc=${String(j.rc)}). outputPgn=${j.outputPgn.length} chars`);
            if (j.outputMissing) logLine('WARN', 'output.pgn not found by runner (empty output).');
            if (j.outputPgn && j.outputPgn.trim()){
              const added = addDiscoveredGamesFromPgn(j.outputPgn);
              if (added > 0) setTab('games');
            }
          }
          qRun.disabled = false;
          updateQueryUi();
        }
      });

    }catch(e){
      logLine('ERR', `Run exception: ${e && e.stack ? e.stack : String(e)}`);
      qRun.disabled = false;
      updateQueryUi();
      setTab('errors');
    }
  });

  // ---------- boot ----------
  try {
    diag();

    if (typeof Chess === 'undefined') {
      logLine('ERR', 'Chess is undefined. chess.js did not load (CDN blocked?).');
      setTab('errors');
      return;
    }
    if (typeof Chessboard === 'undefined') {
      logLine('ERR', 'Chessboard is undefined. chessboard.js did not load (CDN blocked?), or jQuery missing.');
      setTab('errors');
      return;
    }

    game = new Chess();
    setTool(Tool.NONE);
    renderGameList();

    // CHANGED: size square before first render
    sizeBoardSquare();
    loadGame('mock1');

    updateQueryUi();
    logLine('OK', 'Boot complete.');
  } catch (e) {
    logLine('ERR', `Boot exception: ${e && e.stack ? e.stack : String(e)}`);
    setTab('errors');
  }
})();
</script>
</body>
</html>
