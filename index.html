<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Priyome</title>
  <link href="./favicon.svg" rel="icon">

  <!-- chessboard.js (requires jQuery) -->
  <link rel="stylesheet"
        href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
        integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU"
        crossorigin="anonymous">
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"
          integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2"
          crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
          integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD"
          crossorigin="anonymous"></script>
  <!-- chess.js UMD (global Chess) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.11.0/chess.min.js"
          crossorigin="anonymous"></script>

  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --text:#0f172a;
      --muted:#475569;
      --border:#dbe3f0;
      --accent:#2563eb;
      --green:#16a34a;
      --radius:14px;
      --shadow:0 10px 22px rgba(15,23,42,.08);
      --bad:#dc2626;
      --warn:#d97706;
    }
    *{box-sizing:border-box}
    html, body { height: 100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      overflow:auto;
      padding-bottom:5vh;
    }

    button{
      border:1px solid var(--border);
      background: #ffffff;
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
    }
    button:hover{filter:brightness(0.98)}
    button.on{
      border-color: rgba(22,163,74,.55);
      box-shadow:0 0 0 1px rgba(22,163,74,.20) inset;
    }

    /* --- Collapsible hamburger top bar --- */
    .topbarWrap{
      position:sticky; top:0; z-index:50;
      background: rgba(246,247,251,.92);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--border);
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      gap:10px;
    }
    .brand{
      display:flex; align-items:center; gap:10px; font-weight:900;
      min-width:0;
    }
    .hamburger{
      width:42px; height:42px;
      display:grid; place-items:center;
      font-size:18px;
      padding:0;
      flex:0 0 auto;
    }
    .brandTitle{font-size:16px; letter-spacing:.2px}
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--border);
      padding:3px 8px;
      border-radius:999px;
      background: rgba(37,99,235,.06);
      white-space:nowrap;
    }

    .menu{
      display:none;
      padding:10px 14px 14px;
      border-top:1px solid var(--border);
      background: rgba(255,255,255,.75);
    }
    .menu.open{display:block;}
    .actions{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    }

    /* --- Layout: board is upper half; panels lower half --- */
    .layout{
      max-width:1240px;
      margin:0 auto;
      padding:14px;
      min-height: calc(100vh - 60px);
      display:grid;
      grid-template-rows: auto 1fr; /* FIX: let board card size itself */
      gap:14px;
      min-height:0;
    }
    @media (max-width:980px){
      .layout{
        padding:10px;
        grid-template-rows: auto 1fr;
      }
    }

    .card{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden; /* IMPORTANT: prevent board overflow past card */
      min-height:0;
    }
    .head{
      padding:10px 12px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border-bottom:1px solid var(--border);
      background: rgba(15,23,42,.02);
    }
    .status{font-size:12px; color:var(--muted)}

    /* Tool color dots */
    .toolDots{ display:inline-flex; gap:6px; margin-left:8px; vertical-align:middle; }
    .dotBtn{
      width:18px; height:18px; padding:0;
      border-radius:999px;
      border:1px solid var(--border);
      background:#fff;
      display:grid; place-items:center;
    }
    .dotBtn.active{ box-shadow:0 0 0 2px rgba(37,99,235,.18); border-color: rgba(37,99,235,.55); }
    .dot{ width:10px; height:10px; border-radius:999px; display:block; }
    .dotG{ background:#16a34a; }
    .dotR{ background:#dc2626; }
    .dotB{ background:#2563eb; }
    .dotY{ background:#d97706; }

    .boardCard{ display:flex; flex-direction:column; min-height:0; }
    .boardArea{
      position:relative;
      padding:12px;
      flex:0 0 auto;         /* FIX: we size this explicitly via JS */
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;       /* FIX: never overflow past card */
    }

    /* square board wrapper; JS sets px size so it always stays square and maximal */
    .boardWrap{
      position:relative;
      width:100%;
      height:100%;
      max-width:800px;       /* FIX: cap to 800x800 */
      max-height:800px;
    }
    #board{
      width:100%;
      height:100%;
    }
    #overlay{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    /* chessboard.js coordinate labels */
    #board .notation-322f9{
      font-size: 9px;
      line-height: 1;
      opacity: .70;
      pointer-events: none;
    }
    #board .alpha-d2270{ left: 2px !important; bottom: 2px !important; }
    #board .numeric-fc462{ right: 2px !important; top: 2px !important; }

    .below{
      padding:10px 12px 12px;
      border-top:1px solid var(--border);
      background: rgba(15,23,42,.02);
      display:grid; gap:8px;
    }
    .fenRow{display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:12px;}
    .fenLabel{color:var(--muted); font-weight:900; letter-spacing:.2px}
    .fenBox{
      flex:1; padding:8px 10px; border-radius:12px;
      border:1px solid var(--border);
      background: rgba(15,23,42,.03);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      overflow:auto; white-space:nowrap;
    }
    .hint{font-size:12px; color:var(--muted); line-height:1.35}

    /* NEW: nav row under the game (replaces FEN under the board) */
    .navRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .navRow .smallBtn{
      padding:8px 10px;
      border-radius:10px;
      font-size:12px;
      font-weight:900;
    }
    .navMeta{
      font-size:12px;
      color:var(--muted);
      padding:6px 8px;
      border-radius:10px;
      border:1px solid var(--border);
      background: rgba(15,23,42,.03);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space:nowrap;
      overflow:auto;
      flex:1;
      min-width:240px;
    }

    .tabs{
      display:flex; gap:8px;
      padding:10px;
      border-bottom:1px solid var(--border);
      background: rgba(15,23,42,.02);
    }
    .tab{
      padding:8px 10px; border-radius:12px;
      border:1px solid var(--border);
      background: rgba(15,23,42,.02);
      color:var(--muted);
      font-weight:900; font-size:12px; cursor:pointer;
      user-select:none;
    }
    .tab.active{
      color:var(--text);
      border-color: rgba(37,99,235,.55);
      box-shadow:0 0 0 1px rgba(37,99,235,.15) inset;
      background: rgba(37,99,235,.06);
    }

    .rightCard{ min-height:0; display:flex; flex-direction:column; }

    .pane{
      display:none;
      padding:12px;
      gap:10px;
      flex:1;
      min-height:0;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    .pane.active{display:flex; flex-direction:column;}

    /* FIX: moves list horizontal */
    .moves{
      overflow:auto;
      padding-right:4px;
      min-height:120px;
      flex:1;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-content:flex-start;
    }

    .moveRow{
      display:inline-flex;   /* FIX: horizontal “tiles” instead of vertical rows */
      gap:8px;
      padding:6px 6px;
      border-radius:12px;
      align-items:flex-start;
      background: rgba(15,23,42,.01);
      border:1px solid rgba(15,23,42,.04);
    }
    .moveRow:hover{background:rgba(15,23,42,.03);}
    .mn{
      width:auto;            /* FIX: don't force a big column */
      color:var(--muted);
      text-align:right;
      padding:6px 8px;
      border-radius:10px;
      background: rgba(15,23,42,.04);
      border:1px solid rgba(15,23,42,.06);
      flex:0 0 auto;
      white-space:nowrap;
    }

    .ply{display:flex; gap:6px; flex-wrap:wrap; flex:1;}
    .ply button{
      padding:5px 8px;
      border-radius:12px;
      background:transparent;
      border:1px solid transparent;
      font-weight:700;
      white-space:nowrap;
    }
    .ply button:hover{border-color:var(--border); background:rgba(15,23,42,.03);}
    .ply button.active{border-color:rgba(22,163,74,.55);}

    .cmt{
      display:inline-block;
      padding:2px 6px;
      border-radius:10px;
      border:1px solid rgba(15,23,42,.08);
      background: rgba(15,23,42,.03);
      color: rgba(15,23,42,.72);
      font-size:12px;
      line-height:1.25;
      max-width: 100%;
      white-space: normal;
    }

    textarea{
      width:100%;
      min-height:140px;
      resize:vertical;
      border-radius:12px; border:1px solid var(--border);
      background: rgba(15,23,42,.02);
      color:var(--text);
      padding:10px; outline:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    textarea:focus{border-color:rgba(37,99,235,.55); box-shadow:0 0 0 3px rgba(37,99,235,.10);}

    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .row label{min-width:120px; font-size:12px; color:var(--muted); font-weight:900}
    input[type="file"]{padding:6px}
    .smallBtn{padding:8px 10px; border-radius:10px; font-size:12px; font-weight:900;}

    .gameList{overflow:auto; display:flex; flex-direction:column; gap:10px; min-height:120px; flex:1;}
    .gameCard{
      border:1px solid var(--border);
      background: rgba(15,23,42,.02);
      border-radius:14px;
      padding:10px;
      cursor:pointer;
    }
    .gameCard:hover{filter:brightness(0.99)}
    .gameCard.active{border-color:rgba(37,99,235,.55); box-shadow:0 0 0 1px rgba(37,99,235,.12) inset;}
    .gameTitle{font-weight:900; font-size:13px; margin-bottom:4px;}
    .meta{font-size:12px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap;}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid var(--border);
      background: rgba(15,23,42,.02);
      color: rgba(15,23,42,.78);
    }

    /* Errors tab console */
    .errorTools{
      display:flex; gap:8px; align-items:center; justify-content:space-between;
      flex-wrap:wrap;
    }
    .errorBody{
      padding:10px 12px 12px;
      border:1px solid rgba(220,38,38,.25);
      background: rgba(220,38,38,.05);
      border-radius: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      white-space:pre-wrap;
      color:#7f1d1d;
      overflow:auto;
      min-height:160px;
      flex:1;
    }
    .okLine{color:#166534}
    .warnLine{color:#92400e}

    /* Eval list */
    .evalList{display:flex; flex-direction:column; gap:10px; min-height:120px; flex:1;}
    .evalCard{
      border:1px solid var(--border);
      background: rgba(15,23,42,.02);
      border-radius:14px;
      padding:10px;
    }
    .evalTop{display:flex; align-items:flex-start; justify-content:space-between; gap:10px;}
    .evalName{font-weight:900; font-size:13px;}
    .evalDesc{font-size:12px; color:var(--muted); margin-top:4px; line-height:1.35}
    .evalBtns{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    .evalBtns button{padding:8px 10px; border-radius:10px; font-size:12px; font-weight:900;}

    /* bottom card */
    .bottomWrap{
      max-width:1240px;
      margin:0 auto;
      padding:0 14px 0;
    }
    .bottomGrid{
      padding:12px;
      display:grid;
      gap:10px;
    }
    .bottomGrid textarea{ min-height:180px; }

    /* --- Import PGN modal --- */
    .modalBackdrop{
      position:fixed;
      inset:0;
      background: rgba(15,23,42,.45);
      backdrop-filter: blur(6px);
      display:none;
      z-index:999;
      padding:14px;
    }
    .modalBackdrop.open{display:grid; place-items:center;}
    .modal{
      width:min(980px, 100%);
      height:min(84vh, 860px);
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: 18px;
      box-shadow: 0 20px 60px rgba(15,23,42,.22);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .modalHead{
      padding:12px 14px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: rgba(15,23,42,.02);
    }
    .modalBody{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      flex:1;
      min-height:0;
    }
    #importPgnText{ flex:1; min-height:0; }
  </style>
</head>

<body>
  <div class="topbarWrap">
    <div class="topbar">
      <div class="brand">
        <button class="hamburger" id="btnHamburger" aria-label="Menu">☰</button>
        <span class="brandTitle">Priyome</span>
        <span class="pill" id="studyPill">Mock Study • 3 games</span>
        <span class="pill" id="gamePill">—</span>
      </div>
      <div class="pill" id="diagPill">diagnostics</div>
    </div>
    <div class="menu" id="menu">
      <div class="actions">
        <!-- MOVED: Prev/Next removed from hamburger per request -->
        <button id="btnFlip">Flip</button>
        <button id="btnReset">Reset</button>

        <button id="btnSquares">Squares</button>
        <button id="btnArrows">Arrows</button>
        <button id="btnClear">Clear</button>

        <button id="btnImportPgn">Import PGN</button>

        <button id="btnExportGame">Export Game PGN</button>
        <button id="btnExportStudy">Export Study PGN</button>
      </div>
    </div>
  </div>

  <div class="layout">
    <!-- Top half: board -->
    <div class="card boardCard" id="boardCard">
      <div class="head" id="boardHead">
        <div class="status" id="status">—</div>
        <div class="status">
          Tool: <span id="toolStatus">none</span>
          <span id="toolDots" class="toolDots" hidden>
            <button class="dotBtn" data-color="G" title="Green" aria-label="Green"><span class="dot dotG"></span></button>
            <button class="dotBtn" data-color="R" title="Red" aria-label="Red"><span class="dot dotR"></span></button>
            <button class="dotBtn" data-color="B" title="Blue" aria-label="Blue"><span class="dot dotB"></span></button>
            <button class="dotBtn" data-color="Y" title="Yellow" aria-label="Yellow"><span class="dot dotY"></span></button>
          </span>
        </div>
      </div>

      <div class="boardArea" id="boardArea" tabindex="0" aria-label="Chessboard area">
        <div class="boardWrap" id="boardWrap">
          <div id="board"></div>
          <svg id="overlay" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
        </div>
      </div>

      <div class="below" id="boardBelow">
        <!-- NEW: nav buttons below game (replacing the FEN row under the board) -->
        <div class="navRow">
          <button class="smallBtn" id="btnPrev" type="button">◀︎</button>
          <button class="smallBtn" id="btnNext" type="button">▶︎</button>
          <div class="navMeta" id="fenBox"></div>
        </div>

        <div class="hint" id="hint">
          <b>Squares:</b> tap a square to toggle highlight (colored).<br/>
          <b>Arrows:</b> tap start square, then tap end square to toggle an arrow (colored).<br/>
          Drawings are stored on the <b>current ply</b> and exported inline as <span class="kbd">[%csl]</span>/<span class="kbd">[%cal]</span>.
        </div>
      </div>
    </div>

    <!-- Lower half: tabs -->
    <div class="card rightCard">
      <div class="tabs">
        <div class="tab active" id="tabMoves">Moves</div>
        <div class="tab" id="tabGames">Games</div>
        <div class="tab" id="tabQuery">Query</div>
        <div class="tab" id="tabEvals">Evals</div>
        <div class="tab" id="tabErrors">Errors</div>
      </div>

      <div class="pane active" id="paneMoves">
        <div class="hint">
          Click a move to jump. Annotation is saved per ply and exported as <span class="kbd">{ comment }</span>.
          Drawings appear as <span class="kbd">{ [%csl ...] [%cal ...] }</span> on that ply.
        </div>
        <div class="moves" id="moves"></div>
        <div>
          <div class="hint" id="annoTitle">Annotation</div>
          <textarea id="annoText" placeholder="Add a comment for this ply…"></textarea>
        </div>
      </div>

      <div class="pane" id="paneGames">
        <div class="hint">Games list. Click to load.</div>
        <div class="gameList" id="gameList"></div>
      </div>

      <!-- Query tab -->
      <div class="pane" id="paneQuery">
        <div class="hint">
          Load <span class="kbd">.cql</span> and <span class="kbd">.pgn</span>. CQL becomes editable. Run executes <span class="kbd">/wasm/cql_runner.js</span>.
          Discovered games from output are added to <b>Games</b>.
        </div>

        <div class="row">
          <label for="qCqlFile">CQL file</label>
          <input id="qCqlFile" type="file" accept=".cql"/>
          <span class="kbd" id="qCqlName">—</span>
        </div>

        <div class="row">
          <label for="qPgnFile">PGN file</label>
          <input id="qPgnFile" type="file" accept=".pgn"/>
          <span class="kbd" id="qPgnName">—</span>
        </div>

        <div class="row">
          <label for="qArgv">Argv</label>
          <input id="qArgv" type="text" value="-i /work/game.pgn /work/query.cql"
                 style="width:min(980px,100%); padding:8px 10px; border-radius:12px; border:1px solid var(--border); background:rgba(15,23,42,.02);"/>
        </div>

        <div class="row">
          <label>CQL (editable)</label>
          <span class="kbd">in-memory</span>
        </div>
        <textarea id="qCqlText" placeholder="CQL will load here; you can edit before running…"></textarea>

        <div class="row">
          <button class="smallBtn" id="qRun" disabled>Run Query</button>
          <span class="hint" id="qStatus">Choose files to enable.</span>
        </div>
      </div>

      <!-- Evals tab -->
      <div class="pane" id="paneEvals">
        <div class="hint">
          Evals are loaded from <span class="kbd">./evals.js</span>. Click <b>Run</b> to evaluate the <b>current game</b>.
          Output is added as a new game (and smoke-checked with chess.js first).
          <br/>This tab logs <b>full</b> input/output previews to the error logger.
        </div>

        <div class="row">
          <button class="smallBtn" id="btnReloadEvals" type="button">Reload evals.js</button>
          <span class="kbd" id="evalsStatus">—</span>
        </div>

        <div class="evalList" id="evalList"></div>
      </div>

      <!-- Errors tab -->
      <div class="pane" id="paneErrors">
        <div class="errorTools">
          <div class="hint">All logs and errors show here.</div>
          <div class="row" style="margin-left:auto;">
            <span class="kbd">Lines</span>
            <span class="kbd" id="errCount">0</span>
            <button class="smallBtn" id="btnClearErrors" type="button">Clear</button>
          </div>
        </div>
        <div class="errorBody" id="errorLog"></div>
      </div>
    </div>
  </div>

  <!-- Bottom card for position FEN + game PGN -->
  <div class="bottomWrap">
    <div class="card bottomCard">
      <div class="head">
        <div class="status">Position FEN & Game PGN</div>
        <div class="status" id="bottomMeta">—</div>
      </div>
      <div class="bottomGrid">
        <div class="fenRow">
          <span class="fenLabel">FEN</span>
          <div class="fenBox" id="fenBottom"></div>
        </div>
        <div class="hint">PGN shown includes inline <span class="kbd">{ comments }</span> and inline draw tags <span class="kbd">[%csl]</span>/<span class="kbd">[%cal]</span> at the ply they belong to.</div>
        <textarea id="pgnBottom" readonly></textarea>
      </div>
    </div>
  </div>

  <!-- Import PGN modal -->
  <div class="modalBackdrop" id="importModalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Import PGN">
      <div class="modalHead">
        <div class="status"><b>Import PGN</b> <span class="pill">paste one or more games</span></div>
        <div class="row">
          <button class="smallBtn" id="btnImportCancel" type="button">Cancel</button>
          <button class="smallBtn" id="btnImportAdd" type="button">Add to Games</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="hint">
          Paste PGN here. Multiple games are supported if each game starts with <span class="kbd">[Event "…"]</span>.
        </div>
        <textarea id="importPgnText" placeholder='[Event "Example"]&#10;...'></textarea>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- hamburger menu ----------
  const btnHamburger = document.getElementById('btnHamburger');
  const menu = document.getElementById('menu');
  btnHamburger.addEventListener('click', () => {
    menu.classList.toggle('open');
    sizeBoardSquare();
    if (board && typeof board.resize === 'function') board.resize();
    redrawDrawings();
  });

  // ---------- error logger ----------
  const errorLog = document.getElementById('errorLog');
  const errCount = document.getElementById('errCount');
  let errorLines = [];

  function logLine(kind, msg){
    const ts = new Date().toISOString().slice(11,19);
    const line = `[${ts}] ${kind}: ${msg}`;
    errorLines.push(line);
    errCount.textContent = String(errorLines.length);

    const el = document.createElement('div');
    el.textContent = line;
    if (kind === 'OK') el.className = 'okLine';
    if (kind === 'WARN') el.className = 'warnLine';
    errorLog.appendChild(el);
    errorLog.scrollTop = errorLog.scrollHeight;
  }

  function logBlock(kind, title, value, max=2000){
    const s = (value === undefined) ? 'undefined'
          : (value === null) ? 'null'
          : (typeof value === 'string') ? value
          : (() => { try { return JSON.stringify(value, null, 2); } catch { return String(value); } })();

    const clipped = (s.length > max) ? (s.slice(0, max) + `\n… (${s.length-max} more chars)`) : s;
    logLine(kind, `${title} (${s.length} chars)\n${clipped}`);
  }

  function logStack(kind, prefix, e){
    const msg = e && e.stack ? e.stack : String(e);
    logLine(kind, `${prefix}${msg}`);
  }

  window.addEventListener('error', (e) => {
    const where = e.filename ? ` @ ${e.filename}:${e.lineno}:${e.colno}` : '';
    const detail = (e.error && e.error.stack) ? `\n${e.error.stack}` : '';
    logLine('ERR', `${e.message || 'Error'}${where}${detail}`);
  });

  window.addEventListener('unhandledrejection', (e) => {
    logLine('ERR', `Unhandled promise rejection: ${String(e.reason && e.reason.stack ? e.reason.stack : e.reason)}`);
  });

  document.getElementById('btnClearErrors').addEventListener('click', () => {
    errorLines = [];
    errCount.textContent = '0';
    errorLog.innerHTML = '';
    logLine('OK', 'Cleared error log.');
  });

  // ---------- dependency diagnostics ----------
  function diag(){
    logLine('OK', `User-Agent: ${navigator.userAgent}`);
    const haveJQ = (typeof window.jQuery !== 'undefined');
    logLine(haveJQ ? 'OK' : 'ERR', `jQuery loaded: ${haveJQ}`);

    const haveChessboard = (typeof window.Chessboard !== 'undefined');
    logLine(haveChessboard ? 'OK' : 'ERR', `Chessboard loaded: ${haveChessboard}`);

    const haveChess = (typeof window.Chess !== 'undefined');
    logLine(haveChess ? 'OK' : 'ERR', `Chess (chess.js) loaded: ${haveChess}`);

    const testImg = new Image();
    testImg.onload = () => logLine('OK', 'Piece sprite reachable (wikipedia set).');
    testImg.onerror = () => logLine('ERR', 'Piece sprite failed to load (CDN blocked?).');
    testImg.src = 'https://koblenski.github.io/javascript/chessboardjs-0.3.0/img/chesspieces/wikipedia/Wp.png';
  }

  function colorHex(c){
    switch(c){
      case 'G': return '#16a34a';
      case 'R': return '#dc2626';
      case 'B': return '#2563eb';
      case 'Y': return '#d97706';
      default: return '#16a34a';
    }
  }

  // ---------- mock games ----------
  let GAMES = [
    {
      id:"mock1", title:"Mock Game 1", opening:"English (mock)", result:"1-0",
      pgn:`[Event "Mock Study"]
[Site "Local"]
[Date "2026.01.01"]
[Round "1"]
[White "lexspec"]
[Black "mockbot"]
[Result "1-0"]

1. c4 e5 2. g3 Nf6 3. Bg2 Bc5 4. d3 O-O 5. Nc3 Re8 6. Nf3 c6 7. O-O d5 8. cxd5 cxd5 9. Bg5 Be6 10. Nxe5 1-0`
    },
    {
      id:"mock2", title:"Mock Game 2", opening:"Caro-Kann (mock)", result:"0-1",
      pgn:`[Event "Mock Study"]
[Site "Local"]
[Date "2026.01.01"]
[Round "2"]
[White "mockbot"]
[Black "lexspec"]
[Result "0-1"]

1. e4 c6 2. d4 d5 3. Nc3 dxe4 4. Nxe4 Nd7 5. Ng5 Ngf6 6. Bd3 e6 7. N1f3 h6 8. Nxf7 Kxf7 9. O-O Bd6 0-1`
    },
    {
      id:"mock3", title:"Mock Game 3", opening:"Ruy Lopez (mock)", result:"1/2-1/2",
      pgn:`[Event "Mock Study"]
[Site "Local"]
[Date "2026.01.01"]
[Round "3"]
[White "lexspec"]
[Black "mockbot"]
[Result "1/2-1/2"]

1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8 1/2-1/2`
    },
  ];
  const discoveredIds = new Set();

  // ---------- eval registry ----------
  let EVALS_REGISTRY = [];
  const evalListEl = document.getElementById('evalList');
  const evalsStatusEl = document.getElementById('evalsStatus');

  // ---------- DOM ----------
  const statusEl = document.getElementById('status');
  const fenBox = document.getElementById('fenBox');
  const movesEl = document.getElementById('moves');
  const gameListEl = document.getElementById('gameList');
  const gamePill = document.getElementById('gamePill');
  const toolStatusEl = document.getElementById('toolStatus');
  const toolDotsEl = document.getElementById('toolDots');
  const annoTitleEl = document.getElementById('annoTitle');
  const annoTextEl = document.getElementById('annoText');
  const overlay = document.getElementById('overlay');

  // Bottom card DOM
  const fenBottom = document.getElementById('fenBottom');
  const pgnBottom = document.getElementById('pgnBottom');
  const bottomMeta = document.getElementById('bottomMeta');

  // Query tab DOM
  const qCqlFile = document.getElementById('qCqlFile');
  const qPgnFile = document.getElementById('qPgnFile');
  const qCqlName = document.getElementById('qCqlName');
  const qPgnName = document.getElementById('qPgnName');
  const qCqlText = document.getElementById('qCqlText');
  const qArgv = document.getElementById('qArgv');
  const qRun = document.getElementById('qRun');
  const qStatus = document.getElementById('qStatus');

  // Board sizing DOM
  const boardArea = document.getElementById('boardArea');
  const boardWrap = document.getElementById('boardWrap');
  const boardCard = document.getElementById('boardCard');
  const boardHead = document.getElementById('boardHead');
  const boardBelow = document.getElementById('boardBelow');

  // Import modal DOM
  const importModalBackdrop = document.getElementById('importModalBackdrop');
  const importPgnText = document.getElementById('importPgnText');
  const btnImportCancel = document.getElementById('btnImportCancel');
  const btnImportAdd = document.getElementById('btnImportAdd');
  const btnImportPgn = document.getElementById('btnImportPgn');

  // ---------- state ----------
  let board = null;
  let orientation = 'white';
  let currentGame = null;

  let game = null;
  let verboseHistory = [];
  let activePly = 0;

  // user annotations per ply
  const annotations = Object.create(null);

  // drawings PER PLY
  const drawings = Object.create(null);

  function ensureStores(gameId){
    if (!annotations[gameId]) annotations[gameId] = Object.create(null);
    if (!drawings[gameId]) drawings[gameId] = Object.create(null);
  }

  function ensureDrawAt(gameId, ply){
    ensureStores(gameId);
    const key = String(ply);
    if (!drawings[gameId][key]){
      drawings[gameId][key] = { squares:Object.create(null), arrows:[] };
    }
    return drawings[gameId][key];
  }

  function currentDraw(){
    if (!currentGame) return { squares:Object.create(null), arrows:[] };
    return ensureDrawAt(currentGame.id, activePly);
  }

  const Tool = { NONE:'none', SQUARES:'squares', ARROWS:'arrows' };
  let tool = Tool.NONE;
  let tapFrom = null;

  // Tool color
  let toolColor = 'G'; // G,R,B,Y
  function setToolColor(c){
    toolColor = c;
    document.querySelectorAll('.dotBtn').forEach(b => b.classList.toggle('active', b.dataset.color === c));
    logLine('OK', `Tool color set to: ${c}`);
  }
  document.querySelectorAll('.dotBtn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      setToolColor(btn.dataset.color);
    });
  });
  setToolColor(toolColor);

  // Only suppress navigation gestures while a piece is actively being dragged
  let isDraggingPiece = false;

  function setTool(t){
    tool = t;
    tapFrom = null;
    toolStatusEl.textContent = t;
    toolDotsEl.hidden = (t === Tool.NONE);

    document.getElementById('btnSquares').classList.toggle('on', t === Tool.SQUARES);
    document.getElementById('btnArrows').classList.toggle('on', t === Tool.ARROWS);
    logLine('OK', `Tool set to: ${t}`);
  }

  // ---------- board sizing (square, fills card width; max 800; tries for >=70vh; no overflow) ----------
  function sizeBoardSquare(){
    const cs = getComputedStyle(boardArea);
    const padX = (parseFloat(cs.paddingLeft)||0) + (parseFloat(cs.paddingRight)||0);
    const padY = (parseFloat(cs.paddingTop)||0) + (parseFloat(cs.paddingBottom)||0);

    const wAvail = Math.max(0, boardArea.clientWidth - padX);

    const maxS = 800;
    const minS = Math.floor(window.innerHeight * 0.70);

    // Primary: fill width up to 800
    let s = Math.floor(Math.min(maxS, wAvail));

    // Try to honor 70vh minimum without overflowing the card width
    if (s < minS) s = Math.floor(Math.min(wAvail, minS));

    // Set square size
    boardWrap.style.width = s + 'px';
    boardWrap.style.height = s + 'px';

    // Resize the enclosing card so it hugs the board (no giant empty tray)
    const headH = boardHead ? boardHead.offsetHeight : 0;
    const belowH = boardBelow ? boardBelow.offsetHeight : 0;

    // Ensure boardArea has exactly enough height for the square + its padding
    boardArea.style.height = (s + padY) + 'px';

    // Let the card size naturally; but on some browsers, explicitly setting min-height helps avoid overflow glitches
    boardCard.style.minHeight = (headH + (s + padY) + belowH) + 'px';
  }

  // ---------- overlay ----------
  function clearOverlay(){ while(overlay.firstChild) overlay.removeChild(overlay.firstChild); }

  function ensureDefs(){
    let defs = overlay.querySelector('defs');
    if (!defs){
      defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      overlay.appendChild(defs);
    }
    for (const c of ['G','R','B','Y']){
      if (!overlay.querySelector(`#arrowHead${c}`)){
        const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
        marker.setAttribute('id',`arrowHead${c}`);
        marker.setAttribute('markerWidth','6');
        marker.setAttribute('markerHeight','6');
        marker.setAttribute('refX','5.2');
        marker.setAttribute('refY','3');
        marker.setAttribute('orient','auto');
        marker.setAttribute('markerUnits','strokeWidth');
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d','M0,0 L6,3 L0,6 Z');
        path.setAttribute('fill', colorHex(c));
        marker.appendChild(path);
        defs.appendChild(marker);
      }
    }
  }

  function squareToXY(sq){
    const f = sq.charCodeAt(0)-97;
    const r = parseInt(sq[1],10)-1;
    if (orientation === 'white'){
      return { x:(f+0.5)*12.5, y:(7-r+0.5)*12.5 };
    } else {
      return { x:(7-f+0.5)*12.5, y:(r+0.5)*12.5 };
    }
  }

  function drawSquare(sq, c){
    const {x,y} = squareToXY(sq);
    const size = 12.5;
    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', x - size/2);
    rect.setAttribute('y', y - size/2);
    rect.setAttribute('width', size);
    rect.setAttribute('height', size);
    rect.setAttribute('fill', colorHex(c));
    rect.setAttribute('opacity', '0.16');
    overlay.appendChild(rect);
  }

  function drawArrow(from, to, c){
    const a = squareToXY(from), b = squareToXY(to);
    const dx=b.x-a.x, dy=b.y-a.y;
    const len=Math.hypot(dx,dy)||1;
    const shrink=4;
    const ux=dx/len, uy=dy/len;

    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', a.x);
    line.setAttribute('y1', a.y);
    line.setAttribute('x2', b.x - ux*shrink);
    line.setAttribute('y2', b.y - uy*shrink);
    line.setAttribute('stroke', colorHex(c));
    line.setAttribute('stroke-width', '1.7');
    line.setAttribute('opacity', '0.92');
    line.setAttribute('marker-end', `url(#arrowHead${c})`);
    overlay.appendChild(line);
  }

  function redrawDrawings(){
    clearOverlay();
    ensureDefs();
    if (!currentGame) return;

    const d = currentDraw();
    for (const sq of Object.keys(d.squares)){
      const c = d.squares[sq];
      if (c) drawSquare(sq, c);
    }
    for (const ar of d.arrows){
      drawArrow(ar.from, ar.to, ar.color || 'G');
    }
  }

  // ---------- PGN draw-tags helpers ----------
  function buildCslTag(d){
    const items = Object.keys(d.squares || {}).sort().map(sq => `${d.squares[sq]}${sq}`);
    return items.length ? `[%csl ${items.join(',')}]` : '';
  }
  function buildCalTag(d){
    const items = (d.arrows || []).map(a => `${a.color || 'G'}${a.from}${a.to}`);
    return items.length ? `[%cal ${items.join(',')}]` : '';
  }

  function drawTagsCommentFor(gameId, ply){
    const d = drawings[gameId]?.[String(ply)];
    if (!d) return '';
    const csl = buildCslTag(d);
    const cal = buildCalTag(d);
    const tags = [csl, cal].filter(Boolean).join(' ');
    return tags ? `{ ${tags} }` : '';
  }

  function parseDrawTagsByPlyFromPgn(pgn){
    const out = Object.create(null);
    const body = String(pgn || "")
      .replace(/\r/g,'')
      .replace(/^\s*\[[^\]]+\]\s*$/gm,'')
      .trim();

    let ply = 0;
    const re = /\{[^}]*\}|\d+\.(?:\.\.)?|1-0|0-1|1\/2-1\/2|\*|\S+/g;
    let m;

    while ((m = re.exec(body)) !== null){
      const tok = m[0];

      if (tok.startsWith('{')){
        const txt = tok.slice(1,-1);
        const cslM = txt.match(/\[%csl\s+([^\]]+)\]/);
        const calM = txt.match(/\[%cal\s+([^\]]+)\]/);

        if (cslM || calM){
          const key = String(ply);
          if (!out[key]) out[key] = { squares:Object.create(null), arrows:[] };

          if (cslM){
            for (const part of cslM[1].split(/[\s,]+/).map(s=>s.trim()).filter(Boolean)){
              const c = part[0], sq = part.slice(1);
              if (/^[GRBY]$/.test(c) && /^[a-h][1-8]$/.test(sq)) out[key].squares[sq] = c;
            }
          }
          if (calM){
            for (const part of calM[1].split(/[\s,]+/).map(s=>s.trim()).filter(Boolean)){
              const c = part[0];
              const rest = part.slice(1);
              const from = rest.slice(0,2), to = rest.slice(2,4);
              if (/^[GRBY]$/.test(c) && /^[a-h][1-8]$/.test(from) && /^[a-h][1-8]$/.test(to)){
                out[key].arrows.push({from,to,color:c});
              }
            }
          }
        }
        continue;
      }

      if (/^\d+\.(?:\.\.)?$/.test(tok)) continue;
      if (/^(1-0|0-1|1\/2-1\/2|\*)$/.test(tok)) break;
      ply++;
    }

    return out;
  }

  function parseCommentsByPlyFromPgn(pgn){
    const out = Object.create(null);
    const body = String(pgn || "")
      .replace(/\r/g,'')
      .replace(/^\s*\[[^\]]+\]\s*$/gm,'')
      .trim();

    let ply = 0;
    const re = /\{[^}]*\}|\d+\.(?:\.\.)?|1-0|0-1|1\/2-1\/2|\*|\S+/g;
    let m;

    while ((m = re.exec(body)) !== null){
      const tok = m[0];

      if (tok.startsWith('{')){
        let txt = tok.slice(1,-1);
        txt = txt.replace(/\[%csl\s+[^\]]+\]/g, '').replace(/\[%cal\s+[^\]]+\]/g, '');
        txt = txt.replace(/\s+/g,' ').trim();

        if (txt){
          const key = String(ply);
          out[key] = out[key] ? (out[key] + ' ' + txt).trim() : txt;
        }
        continue;
      }

      if (/^\d+\.(?:\.\.)?$/.test(tok)) continue;
      if (/^(1-0|0-1|1\/2-1\/2|\*)$/.test(tok)) break;
      ply++;
    }

    return out;
  }

  function syncDrawingsToPgn(){
    updateBottomCard();
    renderMoves();
  }

  function toggleSquare(gameId, sq){
    const d = ensureDrawAt(gameId, activePly);
    const cur = d.squares[sq];
    if (cur === toolColor){
      delete d.squares[sq];
      logLine('OK', `Square ${sq} removed @ ply ${activePly}`);
    } else {
      d.squares[sq] = toolColor;
      logLine('OK', `Square ${sq} => ${toolColor} @ ply ${activePly}`);
    }
    redrawDrawings();
    syncDrawingsToPgn();
  }

  function toggleArrow(gameId, from, to){
    if (from === to) return;
    const d = ensureDrawAt(gameId, activePly);
    const key = (from < to) ? `${from}-${to}` : `${to}-${from}`;
    const arr = d.arrows;

    const idx = arr.findIndex(x => {
      const k = (x.from < x.to) ? `${x.from}-${x.to}` : `${x.to}-${x.from}`;
      return k === key;
    });

    if (idx >= 0){
      if ((arr[idx].color || 'G') === toolColor){
        arr.splice(idx, 1);
        logLine('OK', `Arrow ${from}->${to} removed @ ply ${activePly}`);
      } else {
        arr[idx] = { from, to, color: toolColor };
        logLine('OK', `Arrow ${from}->${to} recolored to ${toolColor} @ ply ${activePly}`);
      }
    } else {
      arr.push({ from, to, color: toolColor });
      logLine('OK', `Arrow ${from}->${to} added (${toolColor}) @ ply ${activePly}`);
    }

    redrawDrawings();
    syncDrawingsToPgn();
  }

  function clearAll(gameId){
    const d = ensureDrawAt(gameId, activePly);
    d.squares = Object.create(null);
    d.arrows = [];
    logLine('OK', `Cleared drawings @ ply ${activePly}.`);
    redrawDrawings();
    syncDrawingsToPgn();
  }

  // ---------- tabs ----------
  function setTab(which){
    const map = {
      moves: ['tabMoves','paneMoves'],
      games: ['tabGames','paneGames'],
      query: ['tabQuery','paneQuery'],
      evals: ['tabEvals','paneEvals'],
      errors:['tabErrors','paneErrors'],
    };

    for (const k of Object.keys(map)){
      const [t,p] = map[k];
      document.getElementById(t).classList.toggle('active', k===which);
      document.getElementById(p).classList.toggle('active', k===which);
    }
    logLine('OK', `Tab: ${which}`);
  }

  document.getElementById('tabMoves').addEventListener('click', () => setTab('moves'));
  document.getElementById('tabGames').addEventListener('click', () => setTab('games'));
  document.getElementById('tabQuery').addEventListener('click', () => setTab('query'));
  document.getElementById('tabEvals').addEventListener('click', () => setTab('evals'));
  document.getElementById('tabErrors').addEventListener('click', () => setTab('errors'));

  // ---------- move list / nav ----------
  function rebuildToPly(ply){
    game.reset();
    for (let i=0;i<ply;i++){
      const mv = verboseHistory[i];
      if (!mv) break;
      game.move({from:mv.from,to:mv.to,promotion:mv.promotion||'q'});
    }
  }

  function setStatus(){
    let s = `${game.turn()==='w'?'White':'Black'} to move.`;
    if (game.in_check()) s += ' (Check)';
    if (game.game_over()){
      if (game.in_checkmate()) s = `Checkmate. ${game.turn()==='w'?'Black':'White'} wins.`;
      else if (game.in_draw()) s = 'Draw.';
      else s = 'Game over.';
    }
    statusEl.textContent = s;
  }

  function setFen(){
    const f = game.fen();
    fenBox.textContent = f;
    fenBottom.textContent = f;
  }

  function mergedUserComment(gameId, ply){
    ensureStores(gameId);
    return (annotations[gameId] && annotations[gameId][ply]) ? String(annotations[gameId][ply]).trim() : "";
  }

  function renderMoves(){
    movesEl.innerHTML = '';
    if (!currentGame) return;

    const total = verboseHistory.length;
    const rows = Math.ceil(total/2);

    const startTag = drawTagsCommentFor(currentGame.id, 0);
    if (startTag){
      const row = document.createElement('div');
      row.className = 'moveRow';
      const mn = document.createElement('div');
      mn.className='mn';
      mn.textContent = '0.';
      row.appendChild(mn);

      const ply = document.createElement('div');
      ply.className='ply';
      const s = document.createElement('span');
      s.className = 'cmt';
      s.textContent = startTag;
      ply.appendChild(s);

      row.appendChild(ply);
      movesEl.appendChild(row);
    }

    for (let m=0;m<rows;m++){
      const row = document.createElement('div');
      row.className = 'moveRow';

      const mn = document.createElement('div');
      mn.className='mn';
      mn.textContent = `${m+1}.`;
      row.appendChild(mn);

      const ply = document.createElement('div');
      ply.className='ply';

      const wi = m*2;
      const bi = m*2+1;

      const wBtn = document.createElement('button');
      wBtn.textContent = verboseHistory[wi]?.san || '';
      wBtn.disabled = !verboseHistory[wi];
      if (activePly === wi+1) wBtn.classList.add('active');
      wBtn.onclick = () => jumpTo(wi+1);
      ply.appendChild(wBtn);

      const wTag = drawTagsCommentFor(currentGame.id, wi+1);
      if (wTag){
        const s = document.createElement('span');
        s.className = 'cmt';
        s.textContent = wTag;
        ply.appendChild(s);
      }

      const wc = mergedUserComment(currentGame.id, wi+1);
      if (wc){
        const s = document.createElement('span');
        s.className = 'cmt';
        s.textContent = `{ ${wc} }`;
        ply.appendChild(s);
      }

      const bBtn = document.createElement('button');
      bBtn.textContent = verboseHistory[bi]?.san || '';
      bBtn.disabled = !verboseHistory[bi];
      if (activePly === bi+1) bBtn.classList.add('active');
      bBtn.onclick = () => jumpTo(bi+1);
      ply.appendChild(bBtn);

      const bTag = drawTagsCommentFor(currentGame.id, bi+1);
      if (bTag){
        const s = document.createElement('span');
        s.className = 'cmt';
        s.textContent = bTag;
        ply.appendChild(s);
      }

      const bc = mergedUserComment(currentGame.id, bi+1);
      if (bc){
        const s = document.createElement('span');
        s.className = 'cmt';
        s.textContent = `{ ${bc} }`;
        ply.appendChild(s);
      }

      row.appendChild(ply);
      movesEl.appendChild(row);
    }
  }

  function updateAnnoUI(){
    ensureStores(currentGame.id);
    annoTitleEl.textContent = `Annotation (ply ${activePly}${activePly===0?' / start':''})`;
    annoTextEl.value = annotations[currentGame.id][activePly] || '';
  }

  function updateBottomCard(){
    if (!currentGame){
      bottomMeta.textContent = '—';
      pgnBottom.value = '';
      return;
    }
    bottomMeta.textContent = currentGame.title;
    pgnBottom.value = pgnWithComments(currentGame.id, currentGame.pgn) + '\n';
  }

  function jumpTo(ply){
    activePly = Math.max(0, Math.min(ply, verboseHistory.length));
    rebuildToPly(activePly);
    board.position(game.fen(), false);
    setStatus(); setFen(); renderMoves(); updateAnnoUI(); redrawDrawings();
    updateBottomCard();
    logLine('OK', `Jump to ply ${activePly}`);
  }

  // ---------- board callbacks ----------
  function onDragStart(source, piece){
    if (tool !== Tool.NONE) return false;
    if (game.game_over()) return false;
    if (activePly !== verboseHistory.length) return false;
    if (game.turn()==='w' && piece.startsWith('b')) return false;
    if (game.turn()==='b' && piece.startsWith('w')) return false;

    isDraggingPiece = true;
    return true;
  }

  function onDrop(source,target){
    const mv = game.move({from:source,to:target,promotion:'q'});
    isDraggingPiece = false;
    if (!mv) return 'snapback';
    verboseHistory = game.history({verbose:true});
    activePly = verboseHistory.length;
    setStatus(); setFen(); renderMoves(); updateAnnoUI();
    updateBottomCard();
    logLine('OK', `Move: ${mv.san}`);
  }

  function onSnapEnd(){
    isDraggingPiece = false;
    board.position(game.fen(), false);
  }

  document.addEventListener('touchmove', (e) => {
    if (isDraggingPiece) e.preventDefault();
  }, { passive:false });

  window.addEventListener('mouseup', () => { isDraggingPiece = false; });

  // ---------- square detection ----------
  function squareFromTarget(t){
    const el = t.closest?.('div.square-55d63');
    if (!el) return null;
    const sqClass = Array.from(el.classList).find(c => /^square-[a-h][1-8]$/.test(c));
    return sqClass ? sqClass.slice('square-'.length) : null;
  }

  document.getElementById('boardArea').addEventListener('click', (e) => {
    if (!currentGame) return;
    if (tool === Tool.NONE) return;

    const sq = squareFromTarget(e.target);
    if (!sq) return;

    if (tool === Tool.SQUARES){
      toggleSquare(currentGame.id, sq);
      return;
    }

    if (tool === Tool.ARROWS){
      if (!tapFrom){
        tapFrom = sq;
        logLine('OK', `Arrow start = ${sq} (tap destination)`);
      } else {
        toggleArrow(currentGame.id, tapFrom, sq);
        tapFrom = null;
      }
    }
  });

  // ---------- games list ----------
  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  function renderGameList(){
    gameListEl.innerHTML = '';
    for (const g of GAMES){
      const card = document.createElement('div');
      card.className = 'gameCard' + (currentGame?.id === g.id ? ' active' : '');
      card.innerHTML = `
        <div class="gameTitle">${escapeHtml(g.title)}</div>
        <div class="meta"><span class="kbd">${escapeHtml(g.result || '*')}</span><span>${escapeHtml(g.opening || '')}</span></div>
      `;
      card.onclick = () => loadGame(g.id);
      gameListEl.appendChild(card);
    }
  }

  function loadGame(gameId){
    const g = GAMES.find(x => x.id===gameId);
    if (!g) return;

    currentGame = g;
    ensureStores(g.id);
    gamePill.textContent = g.title;

    drawings[g.id] = parseDrawTagsByPlyFromPgn(g.pgn);

    const parsedComments = parseCommentsByPlyFromPgn(g.pgn);
    const existing = annotations[g.id] || Object.create(null);
    const existingKeys = Object.keys(existing);
    if (existingKeys.length === 0){
      annotations[g.id] = parsedComments;
    } else {
      for (const k of Object.keys(parsedComments)){
        if (!existing[k]) existing[k] = parsedComments[k];
      }
      annotations[g.id] = existing;
    }

    game.reset();
    const ok = game.load_pgn(g.pgn, {sloppy:true});
    logLine(ok ? 'OK' : 'ERR', `load_pgn(${g.title}) => ${ok}`);
    if (!ok){
      logBlock('ERR', `PGN that failed load_pgn(${g.title})`, g.pgn, 20000);
      setTab('errors');
    }

    verboseHistory = game.history({verbose:true});
    activePly = verboseHistory.length;

    sizeBoardSquare();

    if (!board){
      logLine('OK', 'Initializing Chessboard...');
      board = Chessboard('board', {
        draggable:true,
        position: game.fen(),
        pieceTheme: 'https://koblenski.github.io/javascript/chessboardjs-0.3.0/img/chesspieces/wikipedia/{piece}.png',
        onDragStart, onDrop, onSnapEnd
      });
      if (typeof board.resize === 'function') board.resize();
      logLine('OK', 'Chessboard initialized.');
    } else {
      board.position(game.fen(), false);
      if (typeof board.resize === 'function') board.resize();
      logLine('OK', `Chessboard position updated.`);
    }

    setStatus(); setFen(); renderMoves(); updateAnnoUI(); redrawDrawings();
    updateBottomCard();
    renderGameList();
  }

  // ---------- export ----------
  function downloadText(filename, text){
    const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },0);
    logLine('OK', `Downloaded: ${filename}`);
  }

  function pgnWithComments(gameId, basePgn){
    ensureStores(gameId);
    const tmp = new Chess();
    tmp.load_pgn(basePgn, {sloppy:true});
    const headers = tmp.header();
    const hist = tmp.history({verbose:true});
    const ann = annotations[gameId] || {};

    const headerLines = Object.keys(headers).map(k => `[${k} "${String(headers[k]).replaceAll('"','\\"')}"]`);
    if (!headers.Result) headerLines.push(`[Result "*"]`);

    const parts = [];
    const pre = drawTagsCommentFor(gameId, 0);
    if (pre) parts.push(pre);

    for (let i=0;i<hist.length;i++){
      const ply = i+1;
      const moveNo = Math.floor(i/2)+1;
      const san = hist[i].san;

      if (i%2===0) parts.push(`${moveNo}. ${san}`);
      else parts.push(`${san}`);

      const tagCmt = drawTagsCommentFor(gameId, ply);
      if (tagCmt) parts.push(tagCmt);

      const c = (ann[ply]||'').trim();
      if (c) parts.push(`{ ${c.replace(/\s+/g,' ').trim()} }`);
    }

    const result = headers.Result || '*';
    return `${headerLines.join('\n')}\n\n${parts.join(' ')} ${result}`.trim();
  }

  document.getElementById('btnExportGame').onclick = () => {
    if (!currentGame) return;
    downloadText(`${currentGame.title.replace(/\s+/g,'_')}.pgn`, pgnWithComments(currentGame.id, currentGame.pgn) + '\n');
  };
  document.getElementById('btnExportStudy').onclick = () => {
    const blocks = GAMES.map(g => pgnWithComments(g.id, g.pgn));
    downloadText(`Study.pgn`, blocks.join('\n\n\n') + '\n');
  };

  // ---------- buttons ----------
  document.getElementById('btnPrev').onclick = () => { if (game) jumpTo(activePly - 1); };
  document.getElementById('btnNext').onclick = () => { if (game) jumpTo(activePly + 1); };

  document.getElementById('btnFlip').onclick = () => {
    if (!board) return;
    board.flip();
    orientation = (orientation==='white') ? 'black' : 'white';
    redrawDrawings();
    logLine('OK', `Flip => ${orientation}`);
  };

  document.getElementById('btnReset').onclick = () => {
    if (!board || !game) return;
    game.reset();
    verboseHistory = [];
    activePly = 0;
    board.start(false);
    if (typeof board.resize === 'function') board.resize();
    setStatus(); setFen(); renderMoves(); updateAnnoUI(); redrawDrawings();
    updateBottomCard();
    logLine('OK', 'Reset line to start position.');
  };

  document.getElementById('btnSquares').onclick = () => setTool(tool===Tool.SQUARES ? Tool.NONE : Tool.SQUARES);
  document.getElementById('btnArrows').onclick = () => setTool(tool===Tool.ARROWS ? Tool.NONE : Tool.ARROWS);
  document.getElementById('btnClear').onclick = () => { if(currentGame){ clearAll(currentGame.id); } };

  annoTextEl.addEventListener('input', () => {
    if (!currentGame) return;
    ensureStores(currentGame.id);
    annotations[currentGame.id][activePly] = annoTextEl.value;
    updateBottomCard();
    renderMoves();
    logLine('OK', `Annotation saved for ply ${activePly} (${annoTextEl.value.length} chars)`);
  });

  window.addEventListener('resize', () => {
    sizeBoardSquare();
    redrawDrawings();
    if (board && typeof board.resize === 'function') board.resize();
  });

  // ---------- Import PGN modal ----------
  function openImportModal(){
    importModalBackdrop.classList.add('open');
    importModalBackdrop.setAttribute('aria-hidden','false');
    importPgnText.value = '';
    setTimeout(() => importPgnText.focus(), 0);
    logLine('OK', 'Opened Import PGN modal.');
  }
  function closeImportModal(){
    importModalBackdrop.classList.remove('open');
    importModalBackdrop.setAttribute('aria-hidden','true');
    logLine('OK', 'Closed Import PGN modal.');
  }

  btnImportPgn.addEventListener('click', () => openImportModal());
  btnImportCancel.addEventListener('click', () => closeImportModal());
  importModalBackdrop.addEventListener('click', (e) => {
    if (e.target === importModalBackdrop) closeImportModal();
  });
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && importModalBackdrop.classList.contains('open')) closeImportModal();
  });

  function parseHeaders(pgn){
    const headers = {};
    const headerRe = /^\[([A-Za-z0-9_]+)\s+"([^"]*)"\]\s*$/gm;
    let m;
    while ((m = headerRe.exec(pgn)) !== null){
      headers[m[1]] = m[2];
    }
    return headers;
  }

  function splitMultiPgn(text){
    const t = (text || "").trim();
    if (!t) return [];
    const parts = t.split(/\n\s*\n(?=\[Event\s+)/g).map(s => s.trim()).filter(Boolean);
    return parts.length ? parts : [t];
  }

  function addGamesFromText(multiPgnText, sourceLabel){
    const blocks = splitMultiPgn(multiPgnText);
    let added = 0;
    for (let i=0;i<blocks.length;i++){
      const pgn = blocks[i].trim();
      if (!pgn) continue;

      const tmp = new Chess();
      const ok = tmp.load_pgn(pgn, {sloppy:true});
      logLine(ok ? 'OK' : 'ERR', `Import smoke load_pgn(block ${i+1}) => ${ok}`);
      if (!ok){
        logBlock('ERR', `Import block ${i+1} PGN (failed)`, pgn, 20000);
        continue;
      }

      const h = parseHeaders(pgn);
      const title = h.Event ? h.Event : `Imported Game ${i+1}`;
      const white = h.White || "?";
      const black = h.Black || "?";
      const res   = h.Result || "*";

      const id = `${sourceLabel}:${Date.now()}:${Math.random().toString(16).slice(2)}`;
      GAMES.unshift({
        id,
        title: `${title} — ${white} vs ${black}`,
        opening: (h.Opening || sourceLabel),
        result: res,
        pgn
      });
      added++;
    }
    if (added){
      logLine('OK', `Imported ${added} game(s) into Games tab.`);
      renderGameList();
      document.getElementById('studyPill').textContent = `Study • ${GAMES.length} games`;
    }
    return added;
  }

  btnImportAdd.addEventListener('click', () => {
    const txt = importPgnText.value || '';
    if (!txt.trim()){
      logLine('WARN', 'Import PGN: empty input.');
      return;
    }
    const added = addGamesFromText(txt, 'import');
    if (added > 0){
      closeImportModal();
      setTab('games');
    } else {
      setTab('errors');
    }
  });

  // ---------- Query tab ----------
  function updateQueryUi(){
    const haveCql = !!qCqlText.value.trim();
    const havePgn = !!qPgnFile.files?.[0];
    qRun.disabled = !(haveCql && havePgn);
    qStatus.textContent = qRun.disabled ? "Choose PGN and provide CQL (file or edit box) to enable." : "Ready.";
  }

  qCqlFile.addEventListener('change', async () => {
    const f = qCqlFile.files?.[0];
    qCqlName.textContent = f ? f.name : "—";
    if (!f) { updateQueryUi(); return; }
    try{
      const txt = await f.text();
      qCqlText.value = txt;
      logLine('OK', `Loaded CQL file (${txt.length} chars): ${f.name}`);
    }catch(e){
      logLine('ERR', `Failed reading CQL: ${String(e)}`);
    }finally{
      updateQueryUi();
    }
  });

  qPgnFile.addEventListener('change', () => {
    const f = qPgnFile.files?.[0];
    qPgnName.textContent = f ? f.name : "—";
    if (f) logLine('OK', `Selected PGN file: ${f.name}`);
    updateQueryUi();
  });

  qCqlText.addEventListener('input', updateQueryUi);

  async function fileToUint8(file) {
    const ab = await file.arrayBuffer();
    return new Uint8Array(ab);
  }
  function textToUtf8Bytes(text){
    return new TextEncoder().encode(text ?? "");
  }

  function addDiscoveredGamesFromPgn(multiPgnText){
    const games = splitMultiPgn(multiPgnText);
    if (!games.length){
      logLine('WARN', 'No games found in output PGN.');
      return 0;
    }
    let added = 0;
    for (let i=0;i<games.length;i++){
      const pgn = games[i];
      const h = parseHeaders(pgn);
      const title = h.Event ? h.Event : `Discovered Game ${i+1}`;
      const white = h.White || "?";
      const black = h.Black || "?";
      const date  = h.Date || "";
      const res   = h.Result || "*";

      const id = `disc:${(title+"|"+white+"|"+black+"|"+date).replace(/\s+/g,'_').slice(0,160)}`;
      if (discoveredIds.has(id)) continue;
      discoveredIds.add(id);

      GAMES.unshift({
        id,
        title: `${title} — ${white} vs ${black}`,
        opening: (h.Opening || "Discovered"),
        result: res,
        pgn
      });
      added++;
    }
    if (added){
      logLine('OK', `Added ${added} discovered game(s) to Games tab.`);
      renderGameList();
      document.getElementById('studyPill').textContent = `Study • ${GAMES.length} games`;
    }
    return added;
  }

  qRun.addEventListener('click', async () => {
    try{
      const pgnFile = qPgnFile.files?.[0];
      if (!pgnFile) throw new Error("Pick a PGN file.");
      const cqlText = qCqlText.value || "";
      if (!cqlText.trim()) throw new Error("CQL is empty.");

      qRun.disabled = true;
      qStatus.textContent = "Running…";
      logLine('OK', `Running query with argv: ${qArgv.value}`);

      let runCqlWasm;
      try{
        const mod = await import('./wasm/cql_runner.js');
        runCqlWasm = mod.runCqlWasm;
        if (typeof runCqlWasm !== 'function') throw new Error("runCqlWasm export not found");
      }catch(e){
        throw new Error("Failed to load ./wasm/cql_runner.js. " + String(e));
      }

      const cqlBytes = textToUtf8Bytes(cqlText);
      const pgnBytes = await fileToUint8(pgnFile);

      const job = runCqlWasm(cqlBytes, pgnBytes, qArgv.value, {
        onLog: (line) => {
          const s = String(line);
          if (s.startsWith("[stderr]")) logLine('WARN', s);
          else logLine('OK', s);
        }
      });

      const unsub = job.subscribe((j) => {
        const st = j.status ? j.status() : {busy:0,total:1};
        qStatus.textContent = `${j.state} — workers ${st.busy}/${st.total}` + (j.error ? ` — ${j.error}` : "");
        if (j.state === "done" || j.state === "error"){
          unsub();
          if (j.state === "error"){
            logLine('ERR', `Query failed: ${j.error || "unknown error"}`);
            setTab('errors');
          } else {
            logLine('OK', `Query done (rc=${String(j.rc)}). outputPgn=${j.outputPgn.length} chars`);
            if (j.outputMissing) logLine('WARN', 'output.pgn not found by runner (empty output).');
            if (j.outputPgn && j.outputPgn.trim()){
              const added = addDiscoveredGamesFromPgn(j.outputPgn);
              if (added > 0) setTab('games');
            }
          }
          qRun.disabled = false;
          updateQueryUi();
        }
      });

    }catch(e){
      logLine('ERR', `Run exception: ${e && e.stack ? e.stack : String(e)}`);
      qRun.disabled = false;
      updateQueryUi();
      setTab('errors');
    }
  });

  // ---------- Evals tab ----------
  async function loadEvals(){
    evalsStatusEl.textContent = 'loading…';
    try{
      const mod = await import(`./evals.js?ts=${Date.now()}`);
      const list = Array.isArray(mod.EVALS) ? mod.EVALS : (Array.isArray(mod.default) ? mod.default : []);
      EVALS_REGISTRY = list.filter(e => e && typeof e.id === 'string' && typeof e.run === 'function');

      evalsStatusEl.textContent = `${EVALS_REGISTRY.length} eval(s)`;
      logLine('OK', `Loaded evals from ./evals.js: ${EVALS_REGISTRY.map(e=>e.id).join(', ') || '(none)'}`);
      renderEvalList();
    }catch(e){
      evalsStatusEl.textContent = 'load failed';
      logStack('ERR', 'Failed to load ./evals.js: ', e);
      renderEvalList();
      setTab('errors');
    }
  }

  function renderEvalList(){
    evalListEl.innerHTML = '';
    if (!EVALS_REGISTRY.length){
      const d = document.createElement('div');
      d.className = 'hint';
      d.textContent = 'No evals registered. Check ./evals.js exports EVALS (or default) and each entry has {id, run()}.';
      evalListEl.appendChild(d);
      return;
    }

    for (const entry of EVALS_REGISTRY){
      const card = document.createElement('div');
      card.className = 'evalCard';

      const name = entry.name || entry.id;
      const desc = entry.description || '';

      card.innerHTML = `
        <div class="evalTop">
          <div style="min-width:0;">
            <div class="evalName">${escapeHtml(name)} <span class="kbd">${escapeHtml(entry.id)}</span></div>
            <div class="evalDesc">${escapeHtml(desc)}</div>
          </div>
          <div class="evalBtns">
            <button type="button" data-run="${escapeHtml(entry.id)}">Run</button>
          </div>
        </div>
      `;

      card.querySelector('button[data-run]').addEventListener('click', () => runEval(entry));
      evalListEl.appendChild(card);
    }
  }

  async function runEval(entry){
    try{
      if (!currentGame) throw new Error('No current game selected.');
      if (typeof Chess === 'undefined') throw new Error('Chess is undefined (chess.js missing).');

      const evalId = entry.id;
      logLine('OK', `Running eval "${evalId}" on: ${currentGame.title}`);

      const inputPgn = pgnWithComments(currentGame.id, currentGame.pgn) + '\n';
      logBlock('OK', `EVAL/${evalId} INPUT PGN`, inputPgn, 8000);

      const ctx = {
        log:  (s) => logLine('OK',   `EVAL/${evalId}: ${String(s)}`),
        warn: (s) => logLine('WARN', `EVAL/${evalId}: ${String(s)}`),
        err:  (s) => logLine('ERR',  `EVAL/${evalId}: ${String(s)}`),
      };

      let res;
      try{
        ctx.log('calling eval function…');
        res = (entry.run.length >= 2) ? await entry.run(inputPgn, ctx) : await entry.run(inputPgn);
        ctx.log('eval function returned');
      }catch(e){
        logStack('ERR', `Eval run failed (threw): `, e);
        setTab('errors');
        return;
      }

      logBlock('OK', `EVAL/${evalId} RAW RETURN`, res, 8000);

      const outPgn =
        (typeof res === 'string') ? res :
        (res && typeof res.pgn === 'string') ? res.pgn :
        '';

      logBlock('OK', `EVAL/${evalId} OUTPUT PGN`, outPgn, 12000);

      if (!outPgn.trim()) throw new Error(`Eval "${evalId}" returned empty output PGN.`);

      const tmp = new Chess();
      const ok = tmp.load_pgn(outPgn, {sloppy:true});
      logLine(ok ? 'OK' : 'ERR', `EVAL/${evalId} smoke load_pgn(output) => ${ok}`);
      if (!ok){
        logBlock('ERR', `EVAL/${evalId} OUTPUT PGN (FULL; failed smoke)`, outPgn, 50000);
        setTab('errors');
        return;
      }

      const h = parseHeaders(outPgn);
      const titleBase = currentGame.title;
      const title = `Evaluated (${evalId}) • ${titleBase}`;
      const resTok = h.Result || '*';

      const newId = `eval:${evalId}:${currentGame.id}:${Date.now()}:${Math.random().toString(16).slice(2)}`;

      GAMES.unshift({
        id: newId,
        title,
        opening: `Eval: ${entry.name || evalId}`,
        result: resTok,
        pgn: outPgn
      });

      document.getElementById('studyPill').textContent = `Study • ${GAMES.length} games`;
      renderGameList();
      logLine('OK', `Eval added as new game: ${title}`);
      setTab('games');

    }catch(e){
      logStack('ERR', 'Eval run failed: ', e);
      setTab('errors');
    }
  }

  document.getElementById('btnReloadEvals').addEventListener('click', () => loadEvals());

  // ---------- boot ----------
  try {
    diag();

    if (typeof Chess === 'undefined') {
      logLine('ERR', 'Chess is undefined. chess.js did not load (CDN blocked?).');
      setTab('errors');
      return;
    }
    if (typeof Chessboard === 'undefined') {
      logLine('ERR', 'Chessboard is undefined. chessboard.js did not load (CDN blocked?), or jQuery missing.');
      setTab('errors');
      return;
    }

    game = new Chess();
    setTool(Tool.NONE);
    renderGameList();

    sizeBoardSquare();
    loadGame('mock1');
    updateQueryUi();
    loadEvals();

    logLine('OK', 'Boot complete.');
  } catch (e) {
    logLine('ERR', `Boot exception: ${e && e.stack ? e.stack : String(e)}`);
    setTab('errors');
  }
})();
</script>
</body>
</html>
