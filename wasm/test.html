<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CQL Runner (two uploads)</title>
  <style>
    body { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; padding: 16px; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    label { min-width: 120px; }
    input[type="text"] { width: min(980px, 100%); padding: 6px; }
    input[type="file"] { padding: 6px; }
    button { padding: 6px 10px; }
    button:disabled { opacity: 0.5; }
    #log { white-space: pre-wrap; background: #0b0f14; color: #e8eef7; padding: 12px; border-radius: 8px; min-height: 280px; }
    .muted { opacity: 0.75; }
    .hint { font-size: 12px; opacity: 0.75; }
    .mono { font-family: inherit; }
  </style>
</head>
<body>
  <h1>CQL Runner</h1>

  <div class="row">
    <label for="cqlFile">CQL file:</label>
    <input id="cqlFile" type="file" accept=".cql" />
    <span id="cqlChosen" class="muted"></span>
  </div>

  <div class="row">
    <label for="pgnFile">PGN file:</label>
    <input id="pgnFile" type="file" accept=".pgn" />
    <span id="pgnChosen" class="muted"></span>
  </div>

  <div class="row">
    <label for="args">Args template:</label>
    <input id="args" type="text" value="{cql} {pgn}" />
  </div>
  <div class="row hint">
    <span>
      Use placeholders: <span class="mono">{cql}</span> and <span class="mono">{pgn}</span>.
      Example: <span class="mono">-q {cql} -game {pgn}</span>
    </span>
  </div>

  <div class="row">
    <button id="runBtn" disabled>Run</button>
    <button id="clearBtn">Clear log</button>
    <span id="status" class="muted">Ready. Choose files.</span>
  </div>

  <h3>Console</h3>
  <div id="log"></div>

  <!-- NEW: output.pgn archive -->
  <h3>output.pgn history</h3>
  <div id="outputs"></div>

  <script>
    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    const runBtn = document.getElementById('runBtn');
    const clearBtn = document.getElementById('clearBtn');
    const cqlInput = document.getElementById('cqlFile');
    const pgnInput = document.getElementById('pgnFile');
    const cqlChosen = document.getElementById('cqlChosen');
    const pgnChosen = document.getElementById('pgnChosen');
    const outputsEl = document.getElementById('outputs');

    function log(line) {
      logEl.textContent += line + "\n";
      logEl.scrollTop = logEl.scrollHeight;
      console.log(line);
    }

    function setStatus(s) {
      statusEl.textContent = s;
      log("[status] " + s);
    }

    function describeErr(e) {
      if (e instanceof Error) return e.stack || e.message || String(e);
      if (e && typeof e === "object") {
        const parts = [];
        for (const k of ["name","message","errno","code","path","stack"]) {
          if (e[k] != null) parts.push(`${k}=${String(e[k])}`);
        }
        try { parts.push("json=" + JSON.stringify(e)); } catch {}
        return parts.join(" | ") || "[object Object]";
      }
      return String(e);
    }

    window.addEventListener("error", (e) => {
      log("[window.error] " + (e.message || e));
      if (e.error) log("[window.error.detail] " + describeErr(e.error));
    });

    window.addEventListener("unhandledrejection", (e) => {
      log("[unhandledrejection] " + describeErr(e.reason));
    });

    clearBtn.addEventListener("click", () => {
      logEl.textContent = "";
    });

    function updateChosenLabels() {
      cqlChosen.textContent = cqlInput.files?.[0] ? cqlInput.files[0].name : "";
      pgnChosen.textContent = pgnInput.files?.[0] ? pgnInput.files[0].name : "";
      // Enable run only if both files are chosen (worker will load wasm each run)
      runBtn.disabled = !(cqlInput.files?.[0] && pgnInput.files?.[0]);
    }
    cqlInput.addEventListener("change", updateChosenLabels);
    pgnInput.addEventListener("change", updateChosenLabels);

    async function fileToUint8(file) {
      const ab = await file.arrayBuffer();
      return new Uint8Array(ab);
    }

    function appendOutputPgn(title, text) {
      const d = document.createElement("details");
      d.open = false; // collapsed by default

      const s = document.createElement("summary");
      s.textContent = title;

      const pre = document.createElement("pre");
      pre.style.whiteSpace = "pre-wrap";
      pre.style.margin = "10px 0 0 0";
      pre.textContent = text;

      d.appendChild(s);
      d.appendChild(pre);
      outputsEl.appendChild(d);
    }

    // NEW: one-shot worker per run (fresh wasm each click)
    function makeWorker() {
      const cqlJsUrl = new URL("./cql.js", window.location.href).href;
      const baseUrl = new URL("./", window.location.href).href;

      const workerSrc = `
        let _ready = false;
        let _Module = null;
        let _running = false;

        function post(type, payload) {
          self.postMessage(Object.assign({ type }, payload || {}));
        }

        function describeErr(e) {
          if (e instanceof Error) return e.stack || e.message || String(e);
          if (e && typeof e === "object") {
            const parts = [];
            for (const k of ["name","message","errno","code","path","stack"]) {
              if (e[k] != null) parts.push(k + "=" + String(e[k]));
            }
            try { parts.push("json=" + JSON.stringify(e)); } catch {}
            return parts.join(" | ") || "[object Object]";
          }
          return String(e);
        }

        function fsEnsureDir(FS, path) {
          const ap = FS.analyzePath(path);
          if (!ap.exists) FS.mkdir(path);
          const st = FS.stat(path);
          if (!FS.isDir(st.mode)) throw new Error(path + " exists but is not a directory");
        }

        function buildArgvFromTemplate(tpl, cqlPath, pgnPath) {
          const replaced = (tpl || "")
            .replaceAll("{cql}", cqlPath)
            .replaceAll("{pgn}", pgnPath)
            .trim();
          if (!replaced) return [];
          return replaced.split(/\\s+/);
        }

        async function init(baseUrl, cqlJsUrl) {
          if (_ready) return;

          // IMPORTANT: define Module BEFORE loading cql.js
          self.Module = {
            noInitialRun: true,
            __runtimeReady: false,
            print: (text) => post("log", { line: String(text) }),
            printErr: (text) => post("log", { line: "[stderr] " + String(text) }),
            onAbort: (what) => post("log", { line: "[abort] " + String(what) }),
            locateFile: (path) => new URL(path, baseUrl).href,
            setStatus: (s) => post("status", { status: String(s) }),
            onRuntimeInitialized: () => {
              self.Module.__runtimeReady = true;
              _ready = true;
              _Module = self.Module;
              post("status", { status: "Runtime initialized (worker)." });
            }
          };

          try {
            importScripts(cqlJsUrl);
          } catch (e) {
            post("fatal", { error: "Failed to importScripts(cql.js): " + describeErr(e) });
            throw e;
          }

          // Wait for runtime init if needed
          if (!_ready) {
            // Emscripten typically calls onRuntimeInitialized soon after importScripts.
            // Spin microtasks a bit to avoid racing if it's async in your build.
            for (let i = 0; i < 200 && !_ready; i++) {
              await new Promise(r => setTimeout(r, 10));
            }
          }

          if (!_ready || !_Module || typeof _Module.callMain !== "function" || !_Module.FS) {
            throw new Error("Runtime not ready (Module.callMain/Module.FS missing).");
          }
        }

        async function run(payload) {
          if (_running) throw new Error("Worker is already running.");
          _running = true;

          const { baseUrl, cqlJsUrl, cqlBytes, pgnBytes, argsTpl } = payload;

          await init(baseUrl, cqlJsUrl);

          const FS = _Module.FS;
          fsEnsureDir(FS, "/work");

          const cqlPath = "/work/query.cql";
          const pgnPath = "/work/game.pgn";

          post("status", { status: "Writing files into Emscripten FS…" });

          FS.writeFile(cqlPath, new Uint8Array(cqlBytes));
          FS.writeFile(pgnPath, new Uint8Array(pgnBytes));

          post("log", { line: "[FS] wrote " + cqlBytes.byteLength + " bytes to " + cqlPath });
          post("log", { line: "[FS] wrote " + pgnBytes.byteLength + " bytes to " + pgnPath });

          const argv = buildArgvFromTemplate(argsTpl, cqlPath, pgnPath);
          post("log", { line: "[argv] " + ["cql", ...argv].join(" ") });

          post("status", { status: "Running main(argv)…" });

          let rc = 0;
          try {
            rc = _Module.callMain(argv);
            post("log", { line: "[exit] return code: " + rc });
          } catch (e) {
            post("log", { line: "[callMain exception] " + describeErr(e) });
            throw e;
          }

          // Copy output.pgn BEFORE tearing down
          let outText = null;
          const candidates = ["/work/query-out.pgn", "/query-out.pgn", "query-out.pgn"];
          for (const p of candidates) {
            try {
              const ap = FS.analyzePath(p);
              if (ap.exists) {
                const bytes = FS.readFile(p); // Uint8Array
                outText = new TextDecoder("utf-8").decode(bytes);
                break;
              }
            } catch {}
          }

          if (outText != null) {
            post("output", { name: "output.pgn", text: outText });
          } else {
            post("output", { name: "output.pgn", text: "" , missing: true});
          }

          post("done", { rc });
        }

        self.onmessage = async (ev) => {
          const msg = ev.data || {};
          if (msg.type !== "run") return;

          try {
            await run(msg);
          } catch (e) {
            post("error", { error: describeErr(e) });
          } finally {
            // Tear down this worker after each run
            try { self.close(); } catch {}
          }
        };
      `;

      const blob = new Blob([workerSrc], { type: "text/javascript" });
      const url = URL.createObjectURL(blob);
      const w = new Worker(url);
      // Revoke the blob URL once the worker starts using it
      URL.revokeObjectURL(url);

      return { w, cqlJsUrl, baseUrl };
    }

    async function runOnce() {
      runBtn.disabled = true;

      const cqlFile = cqlInput.files?.[0];
      const pgnFile = pgnInput.files?.[0];

      try {
        if (!cqlFile) throw new Error("Pick a .cql file.");
        if (!pgnFile) throw new Error("Pick a .pgn file.");

        setStatus("Reading files…");
        const [cqlBytesU8, pgnBytesU8] = await Promise.all([fileToUint8(cqlFile), fileToUint8(pgnFile)]);

        // Transfer ArrayBuffers to the worker (no copies)
        const cqlBuf = cqlBytesU8.buffer;
        const pgnBuf = pgnBytesU8.buffer;

        const tpl = document.getElementById("args").value;

        setStatus("Starting worker…");
        const { w, cqlJsUrl, baseUrl } = makeWorker();

        const startedAt = new Date();
        const title = `Run ${startedAt.toLocaleString()} — ${cqlFile.name} + ${pgnFile.name}`;

        w.onmessage = (ev) => {
          const m = ev.data || {};
          if (m.type === "log") {
            log(String(m.line || ""));
          } else if (m.type === "status") {
            statusEl.textContent = String(m.status || "");
          } else if (m.type === "output") {
            if (m.missing) {
              log("[warn] output.pgn not found (empty entry added).");
            } else {
              log("[info] captured output.pgn (" + (m.text?.length || 0) + " chars)");
            }
            appendOutputPgn(title, String(m.text || ""));
          } else if (m.type === "done") {
            setStatus("Done.");
          } else if (m.type === "error" || m.type === "fatal") {
            log("[" + m.type + "] " + String(m.error || "unknown error"));
            setStatus("Error (see console).");
          }
        };

        w.onerror = (e) => {
          log("[worker.error] " + (e.message || String(e)));
          setStatus("Error (see console).");
        };

        setStatus("Running in worker…");
        w.postMessage(
          {
            type: "run",
            baseUrl,
            cqlJsUrl,
            cqlBytes: cqlBuf,
            pgnBytes: pgnBuf,
            argsTpl: tpl
          },
          [cqlBuf, pgnBuf]
        );

      } catch (e) {
        log("[exception] " + describeErr(e));
        setStatus("Error (see console).");
      } finally {
        updateChosenLabels();
      }
    }

    runBtn.addEventListener("click", runOnce);

    // initial
    updateChosenLabels();
  </script>
</body>
</html>
